
//! Module token is generated by GoGLL. Do not edit

extern crate lazy_static;

use std::rc::Rc;
use std::fmt;
use lazy_static::lazy_static;
use std::collections::HashMap;

/// Token is returned by the lexer for every scanned lexical token
pub struct Token {
	pub typ: Type,
	pub lext: usize, 
	pub rext: usize,
	
	input: Rc<Vec<char>>,
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub enum Type {	
	Error, // "Error"
	EOF, // "$"
	T_0, // "("
	T_1, // ")"
	T_2, // "++"
	T_3, // "--"
	T_4, // ":"
	T_5, // ";"
	T_6, // "="
	T_7, // "comment"
	T_8, // "config"
	T_9, // "float_literal"
	T_10, // "for"
	T_11, // "func"
	T_12, // "identifier"
	T_13, // "integer_literal"
	T_14, // "let"
	T_15, // "return"
	T_16, // "string_literal"
	T_17, // "{"
	T_18, // "}"
}

/**
New returns a new token.  
lext is the left extent and rext the right extent of the token in the input.  
input is the input slice scanned by the lexer.
*/
pub fn new<'a>(t: Type, lext: usize, rext: usize, input: &Rc<Vec<char>>) -> Rc<Token> {
	Rc::new(Token{
		typ:   t,
		lext:  lext,
		rext:  rext,
		input: input.clone(),
	})
}

impl Token {
	/// get_line_column returns the (line, column) of the left extent of the token
	pub fn get_line_column(&self) -> (usize, usize) {
		let mut line = 1;
		let mut col = 1;
		let mut j = 0;
		while j < self.lext {
			match self.input[j] {
			'\n' => {
				line += 1;
				col = 1
			},
			'\t' => col += 4,
			_ => col += 1
			}
			j += 1
		}
		(line, col)
	}

	/// returns the id of the token
	#[allow(dead_code)]
	pub fn id(&self) -> &'static str {
		TYPE_TO_ID[&self.typ]
	}
	
	/// literal returns the literal runes of t scanned by the lexer
	pub fn literal(&self) -> Vec<char> {
		self.input[self.lext..self.rext].to_vec()
	}
	
    /// literal_string returns the literal string of t scanned by the lexer
    #[allow(dead_code)]
	pub fn literal_string(&self) -> String {
		self.literal().iter().collect::<String>()
	}
	
	/// returns true iff this token is suppressed by the lexer
	#[allow(dead_code)]
	pub fn suppress(&self) -> bool {
		SUPPRESS[&self.typ]
	}

} // impl Token

impl <'a>fmt::Display for Token {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let (ln, col) = self.get_line_column();
		write!(f, "({}, ({},{}) {})", 
			self.typ, ln, col, self.literal().iter().collect::<String>())
	}

}

impl <'a>Type {
	/// id returns the token type ID of token Type t
	#[allow(dead_code)]
	pub fn id(&self) -> &'a str {
		TYPE_TO_ID[self]
	}
	
}

impl <'a>fmt::Display for Type {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}", TYPE_TO_ID[self])
	}

}

lazy_static! {
    static ref TYPE_TO_ID: HashMap<Type, &'static str> = {
        let mut m = HashMap::new(); 
		m.insert(Type::Error, "Error");
		m.insert(Type::EOF, "$");
		m.insert(Type::T_0, "(");
		m.insert(Type::T_1, ")");
		m.insert(Type::T_2, "++");
		m.insert(Type::T_3, "--");
		m.insert(Type::T_4, ":");
		m.insert(Type::T_5, ";");
		m.insert(Type::T_6, "=");
		m.insert(Type::T_7, "comment");
		m.insert(Type::T_8, "config");
		m.insert(Type::T_9, "float_literal");
		m.insert(Type::T_10, "for");
		m.insert(Type::T_11, "func");
		m.insert(Type::T_12, "identifier");
		m.insert(Type::T_13, "integer_literal");
		m.insert(Type::T_14, "let");
		m.insert(Type::T_15, "return");
		m.insert(Type::T_16, "string_literal");
		m.insert(Type::T_17, "{");
		m.insert(Type::T_18, "}");
        m
    };
}

lazy_static! {
	static ref ID_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); 
		m.insert("Error", Type::Error); 
		m.insert("$", Type::EOF); 
		m.insert("(", Type::T_0); 
		m.insert(")", Type::T_1); 
		m.insert("++", Type::T_2); 
		m.insert("--", Type::T_3); 
		m.insert(":", Type::T_4); 
		m.insert(";", Type::T_5); 
		m.insert("=", Type::T_6); 
		m.insert("comment", Type::T_7); 
		m.insert("config", Type::T_8); 
		m.insert("float_literal", Type::T_9); 
		m.insert("for", Type::T_10); 
		m.insert("func", Type::T_11); 
		m.insert("identifier", Type::T_12); 
		m.insert("integer_literal", Type::T_13); 
		m.insert("let", Type::T_14); 
		m.insert("return", Type::T_15); 
		m.insert("string_literal", Type::T_16); 
		m.insert("{", Type::T_17); 
		m.insert("}", Type::T_18); 
		m
	};
}

lazy_static! {
	static ref STRING_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); 
		m.insert("Error", Type::Error); 
		m.insert("EOF", Type::EOF); 
		m.insert("T_0", Type::T_0); 
		m.insert("T_1", Type::T_1); 
		m.insert("T_2", Type::T_2); 
		m.insert("T_3", Type::T_3); 
		m.insert("T_4", Type::T_4); 
		m.insert("T_5", Type::T_5); 
		m.insert("T_6", Type::T_6); 
		m.insert("T_7", Type::T_7); 
		m.insert("T_8", Type::T_8); 
		m.insert("T_9", Type::T_9); 
		m.insert("T_10", Type::T_10); 
		m.insert("T_11", Type::T_11); 
		m.insert("T_12", Type::T_12); 
		m.insert("T_13", Type::T_13); 
		m.insert("T_14", Type::T_14); 
		m.insert("T_15", Type::T_15); 
		m.insert("T_16", Type::T_16); 
		m.insert("T_17", Type::T_17); 
		m.insert("T_18", Type::T_18); 
		m
	};
}

lazy_static! {
    static ref SUPPRESS: HashMap<Type, bool> = {
        let mut m = HashMap::new(); 
		m.insert(Type::Error, false);
		m.insert(Type::EOF, false);
		m.insert(Type::T_0, false);
		m.insert(Type::T_1, false);
		m.insert(Type::T_2, false);
		m.insert(Type::T_3, false);
		m.insert(Type::T_4, false);
		m.insert(Type::T_5, false);
		m.insert(Type::T_6, false);
		m.insert(Type::T_7, true);
		m.insert(Type::T_8, false);
		m.insert(Type::T_9, false);
		m.insert(Type::T_10, false);
		m.insert(Type::T_11, false);
		m.insert(Type::T_12, false);
		m.insert(Type::T_13, false);
		m.insert(Type::T_14, false);
		m.insert(Type::T_15, false);
		m.insert(Type::T_16, false);
		m.insert(Type::T_17, false);
		m.insert(Type::T_18, false);
        m
    };
}
