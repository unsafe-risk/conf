// Module symbols is generated by gogll. Do not edit.

use std::fmt;

#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum Symbol {
    NT(NT),
    T(T)
}

// NT is the type of non-terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum NT { 
    Assignment_Statement,
    Compound_Statement,
    Declaration_Statement,
    Empty_Statement,
    Expression,
    Expression_Statement,
    For,
    Function_Argument,
    Function_Argument_List,
    Function_Argument_List_Body,
    Function_Statement,
    GoGLL,
    Identifier_Expression,
    IncDec_Expression,
    Literal_Expression,
    Return_Statement,
    Simple_Statement,
    Statement,
    Statement_List,
}

// T is the type of terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum T { 
    T0, // ( 
    T1, // ) 
    T2, // ++ 
    T3, // -- 
    T4, // : 
    T5, // ; 
    T6, // = 
    T7, // comment 
    T8, // config 
    T9, // float_literal 
    T10, // for 
    T11, // func 
    T12, // identifier 
    T13, // integer_literal 
    T14, // let 
    T15, // return 
    T16, // string_literal 
    T17, // { 
    T18, // } 	
}

/// Format a &Vec<Symbol> into a String
#[allow(dead_code)]
pub fn to_string(symbols: &Vec<Symbol>) -> String {
    let mut st: String = "".to_string();
    for sym in symbols.iter() {
        st.push_str(&format!("{} ",sym));
    }
    st
}

impl Symbol {
    #[allow(dead_code)]
    pub fn is_nt(&self) -> bool {
        match self {
            Symbol::NT(_) => return true,
            Symbol::T(_) => return false,
        }
    }
}

impl fmt::Display for NT {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            NT::Assignment_Statement => write!(f, "Assignment_Statement"), 
            NT::Compound_Statement => write!(f, "Compound_Statement"), 
            NT::Declaration_Statement => write!(f, "Declaration_Statement"), 
            NT::Empty_Statement => write!(f, "Empty_Statement"), 
            NT::Expression => write!(f, "Expression"), 
            NT::Expression_Statement => write!(f, "Expression_Statement"), 
            NT::For => write!(f, "For"), 
            NT::Function_Argument => write!(f, "Function_Argument"), 
            NT::Function_Argument_List => write!(f, "Function_Argument_List"), 
            NT::Function_Argument_List_Body => write!(f, "Function_Argument_List_Body"), 
            NT::Function_Statement => write!(f, "Function_Statement"), 
            NT::GoGLL => write!(f, "GoGLL"), 
            NT::Identifier_Expression => write!(f, "Identifier_Expression"), 
            NT::IncDec_Expression => write!(f, "IncDec_Expression"), 
            NT::Literal_Expression => write!(f, "Literal_Expression"), 
            NT::Return_Statement => write!(f, "Return_Statement"), 
            NT::Simple_Statement => write!(f, "Simple_Statement"), 
            NT::Statement => write!(f, "Statement"), 
            NT::Statement_List => write!(f, "Statement_List"),
        }
    }
}

impl fmt::Display for T {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            T::T0 => write!(f, "("), 
            T::T1 => write!(f, ")"), 
            T::T2 => write!(f, "++"), 
            T::T3 => write!(f, "--"), 
            T::T4 => write!(f, ":"), 
            T::T5 => write!(f, ";"), 
            T::T6 => write!(f, "="), 
            T::T7 => write!(f, "comment"), 
            T::T8 => write!(f, "config"), 
            T::T9 => write!(f, "float_literal"), 
            T::T10 => write!(f, "for"), 
            T::T11 => write!(f, "func"), 
            T::T12 => write!(f, "identifier"), 
            T::T13 => write!(f, "integer_literal"), 
            T::T14 => write!(f, "let"), 
            T::T15 => write!(f, "return"), 
            T::T16 => write!(f, "string_literal"), 
            T::T17 => write!(f, "{{"), 
            T::T18 => write!(f, "}}"),
        }
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { 
            Symbol::NT(nt) => write!(f, "{}", nt),
            Symbol::T(t) => write!(f, "{}", t)
        }
    }
}

