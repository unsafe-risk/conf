//! Module parser is generated by GoGLL. Do not edit.

extern crate lazy_static;

pub mod bsr;
mod slot;
mod symbols;

use crate::lexer;
use crate::token;
use slot::{Label};
use symbols::{NT,Symbol};

use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use std::fmt;
use std::rc::Rc;

struct Parser {
	c_i: usize,

	r: Vec<Rc<Descriptor>>,
	u: Vec<Rc<Descriptor>>,

	popped:    HashSet<Box<PoppedNode>>,
	crf:       HashMap<ClusterNode, HashSet<CRFNode>>,
	crf_nodes: HashSet<CRFNode>,

	lex:    Rc<lexer::Lexer>,
	errors: Vec<Box<ParseError>>,

	bsr_set: Box<bsr::Set>,
}

#[derive(Hash,Eq,PartialEq,Debug)]
struct Descriptor {
	l: Label,
	k: usize,
	i: usize,
}

/**
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
pub struct Error {
	/// Index of token that caused the error.
	pub c_i: usize,

	/// Grammar slot at which the error occured.
	pub slot: Label,

	/// The token at which the error occurred.
	pub token: Rc<token::Token>,

	/// The tokens expected at the point where the error occurred
    pub expected: Box<HashSet<token::Type>>,
    
    /// The line in the input where the error occurred
    pub line: usize,

    /// The column on the line where the error occurred
    pub column: usize,
}

// ParseErrors are generated during the parse. After a failed parse they 
// are translated to Errors, which are returned to the user.
struct ParseError {
    c_i: usize,
    slot: Label,
    token: Rc<token::Token>,
    expected: Expected,
}

// Expected indicates whether to use the First or Follow set for the exported error.
enum Expected {
    First,
    Follow(NT)
}

#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct PoppedNode {
	x: NT,
    k: usize,
    j: usize,
}

#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct ClusterNode {
	x: symbols::NT,
	k: usize,
}

// Call return forest node
#[derive(Hash, Eq, PartialEq, Debug, Clone, Copy)]
struct CRFNode {
	l: Label,
	i: usize,
}

/// Parse returns the BSR set containing the parse forest.
/// If the parse was successfull the length of Vec\<Box\<Error\>\> = 0.
#[allow(dead_code)]
pub fn parse(l: Rc<lexer::Lexer>) -> (Box<bsr::Set>, Vec<Box<Error>>) {
    let mut p = Parser::new(l.clone());
    p.parse();
    if !p.bsr_set.contain(&NT::GoGLL, 0, l.tokens.len()-1) {
        let errors = p.export_errors();
        (p.bsr_set, errors)
    } else {
        (p.bsr_set, vec![])
    }
}

impl Parser {
    fn new(l: Rc<lexer::Lexer>) -> Box<Parser> {
        let mut p = Box::new(Parser{
            c_i:         0,
            lex:         l.clone(),
            r:           Vec::with_capacity(1024),
            u:           Vec::with_capacity(1024),
            popped:      HashSet::with_capacity(1024),
            crf:         HashMap::with_capacity(1024),
            crf_nodes:   HashSet::with_capacity(1024),
            bsr_set:     bsr::Set::new(NT::GoGLL, l.clone()),
            errors:      Vec::with_capacity(1024),
        });
        p.crf.insert(ClusterNode::new(NT::GoGLL, 0), HashSet::with_capacity(128));
        p
    }

    fn parse(&mut self) {
        // let mut c_u = 0;
        self.nt_add(NT::GoGLL, 0);
        // let mut slotNo = 0;
        while self.r.len() > 0 {
            let (l, c_u, c_i) = self.r_remove();
            self.c_i = c_i;

            // println!("{no}:{l} i {i} u {u} tok {t}", 
            //     no=slotNo, l=l, i=c_i, u=c_u, t=self.lex.tokens[c_i]);
            // slotNo += 1;

            // for d in self.r.iter() {
            //     println!("  {}", d);
            // }

            (|| {
                match l { 
                    // Assignment_Statement : ∙identifier assign Expression semicolon 
                    Label::Assignment_Statement0R0 => { 
                        self.bsr_set.add(Label::Assignment_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Assignment_Statement0R1){ 
                            self.error_first(Label::Assignment_Statement0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Assignment_Statement0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Assignment_Statement0R2){ 
                            self.error_first(Label::Assignment_Statement0R2, self.c_i);
                            return; 
                        }
                        self.call(Label::Assignment_Statement0R3, c_u, self.c_i);
                    },
                    // Assignment_Statement : identifier assign Expression ∙semicolon 
                    Label::Assignment_Statement0R3 => {
                        if !self.test_select(Label::Assignment_Statement0R3){ 
                            self.error_first(Label::Assignment_Statement0R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Assignment_Statement0R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Assignment_Statement) {
                            self.rtn(NT::Assignment_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Assignment_Statement0R0, self.c_i, NT::Assignment_Statement)
                        }
                    }, 
                    // Compound_Statement : ∙lbrace rbrace 
                    Label::Compound_Statement0R0 => { 
                        self.bsr_set.add(Label::Compound_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Compound_Statement0R1){ 
                            self.error_first(Label::Compound_Statement0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Compound_Statement0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Compound_Statement) {
                            self.rtn(NT::Compound_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Compound_Statement0R0, self.c_i, NT::Compound_Statement)
                        }
                    }, 
                    // Compound_Statement : ∙lbrace Statement_List rbrace 
                    Label::Compound_Statement1R0 => { 
                        self.bsr_set.add(Label::Compound_Statement1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Compound_Statement1R1){ 
                            self.error_first(Label::Compound_Statement1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Compound_Statement1R2, c_u, self.c_i);
                    },
                    // Compound_Statement : lbrace Statement_List ∙rbrace 
                    Label::Compound_Statement1R2 => {
                        if !self.test_select(Label::Compound_Statement1R2){ 
                            self.error_first(Label::Compound_Statement1R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Compound_Statement1R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Compound_Statement) {
                            self.rtn(NT::Compound_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Compound_Statement1R0, self.c_i, NT::Compound_Statement)
                        }
                    }, 
                    // Declaration_Statement : ∙let identifier colon identifier assign Expression semicolon 
                    Label::Declaration_Statement0R0 => { 
                        self.bsr_set.add(Label::Declaration_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement0R1){ 
                            self.error_first(Label::Declaration_Statement0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement0R2){ 
                            self.error_first(Label::Declaration_Statement0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement0R3){ 
                            self.error_first(Label::Declaration_Statement0R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement0R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement0R4){ 
                            self.error_first(Label::Declaration_Statement0R4, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement0R5, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement0R5){ 
                            self.error_first(Label::Declaration_Statement0R5, self.c_i);
                            return; 
                        }
                        self.call(Label::Declaration_Statement0R6, c_u, self.c_i);
                    },
                    // Declaration_Statement : let identifier colon identifier assign Expression ∙semicolon 
                    Label::Declaration_Statement0R6 => {
                        if !self.test_select(Label::Declaration_Statement0R6){ 
                            self.error_first(Label::Declaration_Statement0R6, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement0R7, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Declaration_Statement) {
                            self.rtn(NT::Declaration_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Declaration_Statement0R0, self.c_i, NT::Declaration_Statement)
                        }
                    }, 
                    // Declaration_Statement : ∙let config identifier colon identifier assign Expression semicolon 
                    Label::Declaration_Statement1R0 => { 
                        self.bsr_set.add(Label::Declaration_Statement1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R1){ 
                            self.error_first(Label::Declaration_Statement1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R2){ 
                            self.error_first(Label::Declaration_Statement1R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R3){ 
                            self.error_first(Label::Declaration_Statement1R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R4){ 
                            self.error_first(Label::Declaration_Statement1R4, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R5, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R5){ 
                            self.error_first(Label::Declaration_Statement1R5, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R6, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Declaration_Statement1R6){ 
                            self.error_first(Label::Declaration_Statement1R6, self.c_i);
                            return; 
                        }
                        self.call(Label::Declaration_Statement1R7, c_u, self.c_i);
                    },
                    // Declaration_Statement : let config identifier colon identifier assign Expression ∙semicolon 
                    Label::Declaration_Statement1R7 => {
                        if !self.test_select(Label::Declaration_Statement1R7){ 
                            self.error_first(Label::Declaration_Statement1R7, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Declaration_Statement1R8, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Declaration_Statement) {
                            self.rtn(NT::Declaration_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Declaration_Statement1R0, self.c_i, NT::Declaration_Statement)
                        }
                    }, 
                    // Empty_Statement : ∙semicolon 
                    Label::Empty_Statement0R0 => { 
                        self.bsr_set.add(Label::Empty_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Empty_Statement) {
                            self.rtn(NT::Empty_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Empty_Statement0R0, self.c_i, NT::Empty_Statement)
                        }
                    }, 
                    // Expression : ∙IncDec_Expression 
                    Label::Expression0R0 => { 
                        self.call(Label::Expression0R1, c_u, self.c_i);
                    },
                    // Expression : IncDec_Expression ∙
                    Label::Expression0R1 => {
                        if self.follow(NT::Expression) {
                            self.rtn(NT::Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Expression0R0, self.c_i, NT::Expression)
                        }
                    }, 
                    // Expression : ∙Literal_Expression 
                    Label::Expression1R0 => { 
                        self.call(Label::Expression1R1, c_u, self.c_i);
                    },
                    // Expression : Literal_Expression ∙
                    Label::Expression1R1 => {
                        if self.follow(NT::Expression) {
                            self.rtn(NT::Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Expression1R0, self.c_i, NT::Expression)
                        }
                    }, 
                    // Expression : ∙Identifier_Expression 
                    Label::Expression2R0 => { 
                        self.call(Label::Expression2R1, c_u, self.c_i);
                    },
                    // Expression : Identifier_Expression ∙
                    Label::Expression2R1 => {
                        if self.follow(NT::Expression) {
                            self.rtn(NT::Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Expression2R0, self.c_i, NT::Expression)
                        }
                    }, 
                    // Expression_Statement : ∙Expression semicolon 
                    Label::Expression_Statement0R0 => { 
                        self.call(Label::Expression_Statement0R1, c_u, self.c_i);
                    },
                    // Expression_Statement : Expression ∙semicolon 
                    Label::Expression_Statement0R1 => {
                        if !self.test_select(Label::Expression_Statement0R1){ 
                            self.error_first(Label::Expression_Statement0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Expression_Statement0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Expression_Statement) {
                            self.rtn(NT::Expression_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Expression_Statement0R0, self.c_i, NT::Expression_Statement)
                        }
                    }, 
                    // Expression_Statement : ∙semicolon 
                    Label::Expression_Statement1R0 => { 
                        self.bsr_set.add(Label::Expression_Statement1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Expression_Statement) {
                            self.rtn(NT::Expression_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Expression_Statement1R0, self.c_i, NT::Expression_Statement)
                        }
                    }, 
                    // For : ∙for lparen Simple_Statement Expression_Statement Expression rparen Statement 
                    Label::For0R0 => { 
                        self.bsr_set.add(Label::For0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For0R1){ 
                            self.error_first(Label::For0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::For0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For0R2){ 
                            self.error_first(Label::For0R2, self.c_i);
                            return; 
                        }
                        self.call(Label::For0R3, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement ∙Expression_Statement Expression rparen Statement 
                    Label::For0R3 => {
                        if !self.test_select(Label::For0R3){ 
                            self.error_first(Label::For0R3, self.c_i);
                            return; 
                        }
                        self.call(Label::For0R4, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement Expression_Statement ∙Expression rparen Statement 
                    Label::For0R4 => {
                        if !self.test_select(Label::For0R4){ 
                            self.error_first(Label::For0R4, self.c_i);
                            return; 
                        }
                        self.call(Label::For0R5, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement Expression_Statement Expression ∙rparen Statement 
                    Label::For0R5 => {
                        if !self.test_select(Label::For0R5){ 
                            self.error_first(Label::For0R5, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::For0R6, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For0R6){ 
                            self.error_first(Label::For0R6, self.c_i);
                            return; 
                        }
                        self.call(Label::For0R7, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement Expression_Statement Expression rparen Statement ∙
                    Label::For0R7 => {
                        if self.follow(NT::For) {
                            self.rtn(NT::For, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::For0R0, self.c_i, NT::For)
                        }
                    }, 
                    // For : ∙for lparen Simple_Statement Expression_Statement rparen Statement 
                    Label::For1R0 => { 
                        self.bsr_set.add(Label::For1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For1R1){ 
                            self.error_first(Label::For1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::For1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For1R2){ 
                            self.error_first(Label::For1R2, self.c_i);
                            return; 
                        }
                        self.call(Label::For1R3, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement ∙Expression_Statement rparen Statement 
                    Label::For1R3 => {
                        if !self.test_select(Label::For1R3){ 
                            self.error_first(Label::For1R3, self.c_i);
                            return; 
                        }
                        self.call(Label::For1R4, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement Expression_Statement ∙rparen Statement 
                    Label::For1R4 => {
                        if !self.test_select(Label::For1R4){ 
                            self.error_first(Label::For1R4, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::For1R5, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::For1R5){ 
                            self.error_first(Label::For1R5, self.c_i);
                            return; 
                        }
                        self.call(Label::For1R6, c_u, self.c_i);
                    },
                    // For : for lparen Simple_Statement Expression_Statement rparen Statement ∙
                    Label::For1R6 => {
                        if self.follow(NT::For) {
                            self.rtn(NT::For, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::For1R0, self.c_i, NT::For)
                        }
                    }, 
                    // Function_Argument : ∙identifier colon identifier 
                    Label::Function_Argument0R0 => { 
                        self.bsr_set.add(Label::Function_Argument0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Argument0R1){ 
                            self.error_first(Label::Function_Argument0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Argument0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Argument0R2){ 
                            self.error_first(Label::Function_Argument0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Argument0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Function_Argument) {
                            self.rtn(NT::Function_Argument, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument0R0, self.c_i, NT::Function_Argument)
                        }
                    }, 
                    // Function_Argument_List : ∙Function_Argument 
                    Label::Function_Argument_List0R0 => { 
                        self.call(Label::Function_Argument_List0R1, c_u, self.c_i);
                    },
                    // Function_Argument_List : Function_Argument ∙
                    Label::Function_Argument_List0R1 => {
                        if self.follow(NT::Function_Argument_List) {
                            self.rtn(NT::Function_Argument_List, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument_List0R0, self.c_i, NT::Function_Argument_List)
                        }
                    }, 
                    // Function_Argument_List : ∙Function_Argument_List_Body 
                    Label::Function_Argument_List1R0 => { 
                        self.call(Label::Function_Argument_List1R1, c_u, self.c_i);
                    },
                    // Function_Argument_List : Function_Argument_List_Body ∙
                    Label::Function_Argument_List1R1 => {
                        if self.follow(NT::Function_Argument_List) {
                            self.rtn(NT::Function_Argument_List, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument_List1R0, self.c_i, NT::Function_Argument_List)
                        }
                    }, 
                    // Function_Argument_List_Body : ∙Function_Argument comma 
                    Label::Function_Argument_List_Body0R0 => { 
                        self.call(Label::Function_Argument_List_Body0R1, c_u, self.c_i);
                    },
                    // Function_Argument_List_Body : Function_Argument ∙comma 
                    Label::Function_Argument_List_Body0R1 => {
                        if !self.test_select(Label::Function_Argument_List_Body0R1){ 
                            self.error_first(Label::Function_Argument_List_Body0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Argument_List_Body0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Function_Argument_List_Body) {
                            self.rtn(NT::Function_Argument_List_Body, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument_List_Body0R0, self.c_i, NT::Function_Argument_List_Body)
                        }
                    }, 
                    // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument 
                    Label::Function_Argument_List_Body1R0 => { 
                        self.call(Label::Function_Argument_List_Body1R1, c_u, self.c_i);
                    },
                    // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument 
                    Label::Function_Argument_List_Body1R1 => {
                        if !self.test_select(Label::Function_Argument_List_Body1R1){ 
                            self.error_first(Label::Function_Argument_List_Body1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Function_Argument_List_Body1R2, c_u, self.c_i);
                    },
                    // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙
                    Label::Function_Argument_List_Body1R2 => {
                        if self.follow(NT::Function_Argument_List_Body) {
                            self.rtn(NT::Function_Argument_List_Body, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument_List_Body1R0, self.c_i, NT::Function_Argument_List_Body)
                        }
                    }, 
                    // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument comma 
                    Label::Function_Argument_List_Body2R0 => { 
                        self.call(Label::Function_Argument_List_Body2R1, c_u, self.c_i);
                    },
                    // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument comma 
                    Label::Function_Argument_List_Body2R1 => {
                        if !self.test_select(Label::Function_Argument_List_Body2R1){ 
                            self.error_first(Label::Function_Argument_List_Body2R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Function_Argument_List_Body2R2, c_u, self.c_i);
                    },
                    // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙comma 
                    Label::Function_Argument_List_Body2R2 => {
                        if !self.test_select(Label::Function_Argument_List_Body2R2){ 
                            self.error_first(Label::Function_Argument_List_Body2R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Argument_List_Body2R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Function_Argument_List_Body) {
                            self.rtn(NT::Function_Argument_List_Body, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Argument_List_Body2R0, self.c_i, NT::Function_Argument_List_Body)
                        }
                    }, 
                    // Function_Statement : ∙function identifier lparen Function_Argument_List rparen identifier Statement 
                    Label::Function_Statement0R0 => { 
                        self.bsr_set.add(Label::Function_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement0R1){ 
                            self.error_first(Label::Function_Statement0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement0R2){ 
                            self.error_first(Label::Function_Statement0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement0R3){ 
                            self.error_first(Label::Function_Statement0R3, self.c_i);
                            return; 
                        }
                        self.call(Label::Function_Statement0R4, c_u, self.c_i);
                    },
                    // Function_Statement : function identifier lparen Function_Argument_List ∙rparen identifier Statement 
                    Label::Function_Statement0R4 => {
                        if !self.test_select(Label::Function_Statement0R4){ 
                            self.error_first(Label::Function_Statement0R4, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement0R5, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement0R5){ 
                            self.error_first(Label::Function_Statement0R5, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement0R6, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement0R6){ 
                            self.error_first(Label::Function_Statement0R6, self.c_i);
                            return; 
                        }
                        self.call(Label::Function_Statement0R7, c_u, self.c_i);
                    },
                    // Function_Statement : function identifier lparen Function_Argument_List rparen identifier Statement ∙
                    Label::Function_Statement0R7 => {
                        if self.follow(NT::Function_Statement) {
                            self.rtn(NT::Function_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Statement0R0, self.c_i, NT::Function_Statement)
                        }
                    }, 
                    // Function_Statement : ∙function identifier lparen rparen identifier Statement 
                    Label::Function_Statement1R0 => { 
                        self.bsr_set.add(Label::Function_Statement1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement1R1){ 
                            self.error_first(Label::Function_Statement1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement1R2){ 
                            self.error_first(Label::Function_Statement1R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement1R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement1R3){ 
                            self.error_first(Label::Function_Statement1R3, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement1R4, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement1R4){ 
                            self.error_first(Label::Function_Statement1R4, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Function_Statement1R5, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Function_Statement1R5){ 
                            self.error_first(Label::Function_Statement1R5, self.c_i);
                            return; 
                        }
                        self.call(Label::Function_Statement1R6, c_u, self.c_i);
                    },
                    // Function_Statement : function identifier lparen rparen identifier Statement ∙
                    Label::Function_Statement1R6 => {
                        if self.follow(NT::Function_Statement) {
                            self.rtn(NT::Function_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Function_Statement1R0, self.c_i, NT::Function_Statement)
                        }
                    }, 
                    // GoGLL : ∙Statement_List 
                    Label::GoGLL0R0 => { 
                        self.call(Label::GoGLL0R1, c_u, self.c_i);
                    },
                    // GoGLL : Statement_List ∙
                    Label::GoGLL0R1 => {
                        if self.follow(NT::GoGLL) {
                            self.rtn(NT::GoGLL, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::GoGLL0R0, self.c_i, NT::GoGLL)
                        }
                    }, 
                    // Identifier_Expression : ∙identifier 
                    Label::Identifier_Expression0R0 => { 
                        self.bsr_set.add(Label::Identifier_Expression0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Identifier_Expression) {
                            self.rtn(NT::Identifier_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Identifier_Expression0R0, self.c_i, NT::Identifier_Expression)
                        }
                    }, 
                    // IncDec_Expression : ∙identifier inc 
                    Label::IncDec_Expression0R0 => { 
                        self.bsr_set.add(Label::IncDec_Expression0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::IncDec_Expression0R1){ 
                            self.error_first(Label::IncDec_Expression0R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::IncDec_Expression0R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::IncDec_Expression) {
                            self.rtn(NT::IncDec_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::IncDec_Expression0R0, self.c_i, NT::IncDec_Expression)
                        }
                    }, 
                    // IncDec_Expression : ∙identifier dec 
                    Label::IncDec_Expression1R0 => { 
                        self.bsr_set.add(Label::IncDec_Expression1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::IncDec_Expression1R1){ 
                            self.error_first(Label::IncDec_Expression1R1, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::IncDec_Expression1R2, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::IncDec_Expression) {
                            self.rtn(NT::IncDec_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::IncDec_Expression1R0, self.c_i, NT::IncDec_Expression)
                        }
                    }, 
                    // Literal_Expression : ∙integer_literal 
                    Label::Literal_Expression0R0 => { 
                        self.bsr_set.add(Label::Literal_Expression0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Literal_Expression) {
                            self.rtn(NT::Literal_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Literal_Expression0R0, self.c_i, NT::Literal_Expression)
                        }
                    }, 
                    // Literal_Expression : ∙float_literal 
                    Label::Literal_Expression1R0 => { 
                        self.bsr_set.add(Label::Literal_Expression1R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Literal_Expression) {
                            self.rtn(NT::Literal_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Literal_Expression1R0, self.c_i, NT::Literal_Expression)
                        }
                    }, 
                    // Literal_Expression : ∙string_literal 
                    Label::Literal_Expression2R0 => { 
                        self.bsr_set.add(Label::Literal_Expression2R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Literal_Expression) {
                            self.rtn(NT::Literal_Expression, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Literal_Expression2R0, self.c_i, NT::Literal_Expression)
                        }
                    }, 
                    // Return_Statement : ∙return Expression semicolon 
                    Label::Return_Statement0R0 => { 
                        self.bsr_set.add(Label::Return_Statement0R1, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if !self.test_select(Label::Return_Statement0R1){ 
                            self.error_first(Label::Return_Statement0R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Return_Statement0R2, c_u, self.c_i);
                    },
                    // Return_Statement : return Expression ∙semicolon 
                    Label::Return_Statement0R2 => {
                        if !self.test_select(Label::Return_Statement0R2){ 
                            self.error_first(Label::Return_Statement0R2, self.c_i);
                            return; 
                        }
                        self.bsr_set.add(Label::Return_Statement0R3, c_u, self.c_i, self.c_i+1);
                        self.c_i += 1; 
                        if self.follow(NT::Return_Statement) {
                            self.rtn(NT::Return_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Return_Statement0R0, self.c_i, NT::Return_Statement)
                        }
                    }, 
                    // Simple_Statement : ∙Declaration_Statement 
                    Label::Simple_Statement0R0 => { 
                        self.call(Label::Simple_Statement0R1, c_u, self.c_i);
                    },
                    // Simple_Statement : Declaration_Statement ∙
                    Label::Simple_Statement0R1 => {
                        if self.follow(NT::Simple_Statement) {
                            self.rtn(NT::Simple_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Simple_Statement0R0, self.c_i, NT::Simple_Statement)
                        }
                    }, 
                    // Simple_Statement : ∙Assignment_Statement 
                    Label::Simple_Statement1R0 => { 
                        self.call(Label::Simple_Statement1R1, c_u, self.c_i);
                    },
                    // Simple_Statement : Assignment_Statement ∙
                    Label::Simple_Statement1R1 => {
                        if self.follow(NT::Simple_Statement) {
                            self.rtn(NT::Simple_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Simple_Statement1R0, self.c_i, NT::Simple_Statement)
                        }
                    }, 
                    // Simple_Statement : ∙Expression_Statement 
                    Label::Simple_Statement2R0 => { 
                        self.call(Label::Simple_Statement2R1, c_u, self.c_i);
                    },
                    // Simple_Statement : Expression_Statement ∙
                    Label::Simple_Statement2R1 => {
                        if self.follow(NT::Simple_Statement) {
                            self.rtn(NT::Simple_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Simple_Statement2R0, self.c_i, NT::Simple_Statement)
                        }
                    }, 
                    // Simple_Statement : ∙Empty_Statement 
                    Label::Simple_Statement3R0 => { 
                        self.call(Label::Simple_Statement3R1, c_u, self.c_i);
                    },
                    // Simple_Statement : Empty_Statement ∙
                    Label::Simple_Statement3R1 => {
                        if self.follow(NT::Simple_Statement) {
                            self.rtn(NT::Simple_Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Simple_Statement3R0, self.c_i, NT::Simple_Statement)
                        }
                    }, 
                    // Statement : ∙Empty_Statement 
                    Label::Statement0R0 => { 
                        self.call(Label::Statement0R1, c_u, self.c_i);
                    },
                    // Statement : Empty_Statement ∙
                    Label::Statement0R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement0R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement : ∙Simple_Statement 
                    Label::Statement1R0 => { 
                        self.call(Label::Statement1R1, c_u, self.c_i);
                    },
                    // Statement : Simple_Statement ∙
                    Label::Statement1R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement1R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement : ∙Compound_Statement 
                    Label::Statement2R0 => { 
                        self.call(Label::Statement2R1, c_u, self.c_i);
                    },
                    // Statement : Compound_Statement ∙
                    Label::Statement2R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement2R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement : ∙Function_Statement 
                    Label::Statement3R0 => { 
                        self.call(Label::Statement3R1, c_u, self.c_i);
                    },
                    // Statement : Function_Statement ∙
                    Label::Statement3R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement3R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement : ∙Return_Statement 
                    Label::Statement4R0 => { 
                        self.call(Label::Statement4R1, c_u, self.c_i);
                    },
                    // Statement : Return_Statement ∙
                    Label::Statement4R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement4R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement : ∙For 
                    Label::Statement5R0 => { 
                        self.call(Label::Statement5R1, c_u, self.c_i);
                    },
                    // Statement : For ∙
                    Label::Statement5R1 => {
                        if self.follow(NT::Statement) {
                            self.rtn(NT::Statement, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement5R0, self.c_i, NT::Statement)
                        }
                    }, 
                    // Statement_List : ∙Statement 
                    Label::Statement_List0R0 => { 
                        self.call(Label::Statement_List0R1, c_u, self.c_i);
                    },
                    // Statement_List : Statement ∙
                    Label::Statement_List0R1 => {
                        if self.follow(NT::Statement_List) {
                            self.rtn(NT::Statement_List, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement_List0R0, self.c_i, NT::Statement_List)
                        }
                    }, 
                    // Statement_List : ∙Statement_List Statement 
                    Label::Statement_List1R0 => { 
                        self.call(Label::Statement_List1R1, c_u, self.c_i);
                    },
                    // Statement_List : Statement_List ∙Statement 
                    Label::Statement_List1R1 => {
                        if !self.test_select(Label::Statement_List1R1){ 
                            self.error_first(Label::Statement_List1R1, self.c_i);
                            return; 
                        }
                        self.call(Label::Statement_List1R2, c_u, self.c_i);
                    },
                    // Statement_List : Statement_List Statement ∙
                    Label::Statement_List1R2 => {
                        if self.follow(NT::Statement_List) {
                            self.rtn(NT::Statement_List, c_u, self.c_i)
                        } else { 
                            self.error_follow(Label::Statement_List1R0, self.c_i, NT::Statement_List)
                        }
                    }, 
                    _ => unimplemented!()
                };
            })();
        };
    }
    
    fn nt_add(&mut self, nt: NT, j: usize) {
        // println!("nt_add({},{}", nt, j);

        let mut failed = true;
        let mut expected: HashSet<token::Type> = HashSet::with_capacity(128);
        for l in slot::get_alternates(&nt).iter() {
            if self.test_select(*l) {
                self.dsc_add(*l, j, j);
                failed = false
            } else {
                for tok in FIRST[l].iter() {
                    expected.insert(tok.clone());
                }
            }
        }
        if failed {
            for l in slot::get_alternates(&nt) {
                self.error_first(*l, j)
            }
        }
    }

    /*
    suppose that L is Y ::=αX ·β
    if there is no CRF node labelled (L,i)
        create one let u be the CRF node labelled (L,i)
    if there is no CRF node labelled (X, j) {
        create a CRF node v labelled (X, j)
        create an edge from v to u
        nt_add(X, j)
    } else {
        let v be the CRF node labelled (X, j)
        if there is not an edge from v to u {
            create an edge from v to u
            for all ((X, j,h)∈P) {
                dscAdd(L, i, h);
                bsrAdd(L, i, j, h)
            }
        }
    }
    */
    fn call(&mut self, l: Label, i: usize, j: usize) {
        let u = CRFNode::new(l, i);
        if let None = self.crf_nodes.get(&u) {
            self.crf_nodes.insert(u);
        }
        let x = match l.symbols()[l.pos()-1]{
            Symbol::NT(x) => x,
            _ => panic!("Symbol::T is invalid"),
        };
        let nd_v = ClusterNode::new(x, j);
        match self.crf.get_mut(&nd_v) {
            None => {
                let mut m: HashSet<CRFNode> = HashSet::with_capacity(128);
                m.insert(u);
                self.crf.insert(nd_v, m);
                self.nt_add(x, j);
            },
            Some(v) => {
                if !v.contains(&u) {
                    v.insert(u);
                    let mut descs: Vec<Rc<Descriptor>> = Vec::new();
                    for pnd in self.popped.iter() {
                        if pnd.x == x && pnd.k == j {
                            descs.push(Descriptor::new(l, i, pnd.j));
                            self.bsr_set.add(l, i, j, pnd.j);
                        }
                    }
                    for d in descs.into_iter() {
                        self.dsc_add(d.l, d.k, d.i)
                    }
                }
            }
        }
    }
    
    fn rtn(&mut self, x: NT, k: usize, j: usize) {
        let pn = PoppedNode::new(x, k, j);
        if !self.popped.contains(&pn) {
            self.popped.insert(pn);
            for nd in self.crf[&ClusterNode::new(x, k)].clone() {
                self.dsc_add(nd.l, nd.i, j);
                self.bsr_set.add(nd.l, nd.i, k, j);
            }
        }
    }
    
    fn dsc_add(&mut self, l: Label, k: usize, i: usize) {
        let d = Descriptor::new(l, k, i);
        if !self.u.contains(&d) {
            self.r.push(d.clone());
            self.u.push(d.clone());
        }
    }
    
    fn r_remove(&mut self) -> (Label, usize, usize) {
        match self.r.pop() {
            Some(d) => return (d.l, d.k, d.i),
            None => panic!("empty")
        }
    }

    fn error_first(&mut self, l: Label, i: usize) {
        self.errors.push(
            Box::new(ParseError{
                c_i: i, 
                slot: l, 
                token: self.lex.tokens[i].clone(), 
                expected: Expected::First,
            })
        );
    }

    fn error_follow(&mut self, l: Label, i: usize, nt: NT) {
        self.errors.push(
            Box::new(ParseError{
                c_i: i, 
                slot: l, 
                token: self.lex.tokens[i].clone(), 
                expected: Expected::Follow(nt),
            })
        );
    }

    fn export_errors(&mut self) -> Vec<Box<Error>> {
        let mut errs: Vec<Box<Error>> = Vec::new();
        self.errors.sort_by(|a,b| a.token.lext.cmp(&b.token.lext));
        for err in self.errors.iter() {
            let (ln, col) = self.lex.get_line_column(err.token.lext);
            errs.push(Box::new(Error{
                c_i: err.c_i,
                slot: err.slot,
                token: err.token.clone(),
                expected: match err.expected {
                    Expected::First => FIRST[&err.slot].clone(),
                    Expected::Follow(nt) => FOLLOW[&nt].clone(),
                },
                line: ln,
                column: col,
            }));
        }
        errs
    }
    
    fn test_select(&self, l: Label) -> bool {
        FIRST[&l].contains(&self.lex.tokens[self.c_i].typ)
    }

    fn follow(&self, nt: NT) -> bool {
        FOLLOW[&nt].contains(&self.lex.tokens[self.c_i].typ)
    }
    
} /*** impl Parser ***/

impl ClusterNode {
    fn new(nt: NT, k: usize) -> ClusterNode {
        ClusterNode{
            x: nt,
            k: k,
        }
    }
}

impl CRFNode {
    fn new(l: Label, i: usize) -> CRFNode {
        CRFNode{
            l: l,
            i: i,
        }
    }
}

impl Descriptor {
    fn new(l: Label, k: usize, i: usize) -> Rc<Descriptor> {
        Rc::new(Descriptor{
            l: l,
            k: k,
            i: i,
        })
    }
}

impl PoppedNode {
    fn new(x: NT, k: usize, j: usize) -> Box<PoppedNode> {
        Box::new(PoppedNode{
            x: x,
            k: k,
            j: j,
        })
    }
}

impl fmt::Display for Descriptor {    
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "l={l},k={k},i={i}", 
            l=self.l,
            k=self.k,
            i=self.i,
        )
    }
}
    
impl fmt::Display for Error {    
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut errs: Vec<String> = Vec::new();
        for tok in self.expected.iter() {
            errs.push(format!("{}",tok));
        };
        write!(f, "Error: {slot}, token {tok}, expected {{{exp}}} at line {ln} col {col}", 
            slot=self.slot,
            tok=self.token,
            exp=errs.join(","),
            ln=self.line,
            col=self.column,
        )
    }
}
    
    lazy_static! {
    static ref FIRST: HashMap<Label, Box<HashSet<token::Type>>> = {
        let mut fmap = HashMap::new(); 
        // Assignment_Statement : ∙identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Assignment_Statement0R0, hset);
        // Assignment_Statement : identifier ∙assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_0); // assign 
            fmap.insert(Label::Assignment_Statement0R1, hset);
        // Assignment_Statement : identifier assign ∙Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Assignment_Statement0R2, hset);
        // Assignment_Statement : identifier assign Expression ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Assignment_Statement0R3, hset);
        // Assignment_Statement : identifier assign Expression semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Assignment_Statement0R4, hset);
        // Compound_Statement : ∙lbrace rbrace 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_17); // lbrace 
            fmap.insert(Label::Compound_Statement0R0, hset);
        // Compound_Statement : lbrace ∙rbrace 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_20); // rbrace 
            fmap.insert(Label::Compound_Statement0R1, hset);
        // Compound_Statement : lbrace rbrace ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Compound_Statement0R2, hset);
        // Compound_Statement : ∙lbrace Statement_List rbrace 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_17); // lbrace 
            fmap.insert(Label::Compound_Statement1R0, hset);
        // Compound_Statement : lbrace ∙Statement_List rbrace 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Compound_Statement1R1, hset);
        // Compound_Statement : lbrace Statement_List ∙rbrace 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_20); // rbrace 
            fmap.insert(Label::Compound_Statement1R2, hset);
        // Compound_Statement : lbrace Statement_List rbrace ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Compound_Statement1R3, hset);
        // Declaration_Statement : ∙let identifier colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_18); // let 
            fmap.insert(Label::Declaration_Statement0R0, hset);
        // Declaration_Statement : let ∙identifier colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Declaration_Statement0R1, hset);
        // Declaration_Statement : let identifier ∙colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_2); // colon 
            fmap.insert(Label::Declaration_Statement0R2, hset);
        // Declaration_Statement : let identifier colon ∙identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Declaration_Statement0R3, hset);
        // Declaration_Statement : let identifier colon identifier ∙assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_0); // assign 
            fmap.insert(Label::Declaration_Statement0R4, hset);
        // Declaration_Statement : let identifier colon identifier assign ∙Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Declaration_Statement0R5, hset);
        // Declaration_Statement : let identifier colon identifier assign Expression ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Declaration_Statement0R6, hset);
        // Declaration_Statement : let identifier colon identifier assign Expression semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Declaration_Statement0R7, hset);
        // Declaration_Statement : ∙let config identifier colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_18); // let 
            fmap.insert(Label::Declaration_Statement1R0, hset);
        // Declaration_Statement : let ∙config identifier colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_5); // config 
            fmap.insert(Label::Declaration_Statement1R1, hset);
        // Declaration_Statement : let config ∙identifier colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Declaration_Statement1R2, hset);
        // Declaration_Statement : let config identifier ∙colon identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_2); // colon 
            fmap.insert(Label::Declaration_Statement1R3, hset);
        // Declaration_Statement : let config identifier colon ∙identifier assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Declaration_Statement1R4, hset);
        // Declaration_Statement : let config identifier colon identifier ∙assign Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_0); // assign 
            fmap.insert(Label::Declaration_Statement1R5, hset);
        // Declaration_Statement : let config identifier colon identifier assign ∙Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Declaration_Statement1R6, hset);
        // Declaration_Statement : let config identifier colon identifier assign Expression ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Declaration_Statement1R7, hset);
        // Declaration_Statement : let config identifier colon identifier assign Expression semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Declaration_Statement1R8, hset);
        // Empty_Statement : ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Empty_Statement0R0, hset);
        // Empty_Statement : semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Empty_Statement0R1, hset);
        // Expression : ∙IncDec_Expression 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Expression0R0, hset);
        // Expression : IncDec_Expression ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Expression0R1, hset);
        // Expression : ∙Literal_Expression 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Expression1R0, hset);
        // Expression : Literal_Expression ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Expression1R1, hset);
        // Expression : ∙Identifier_Expression 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Expression2R0, hset);
        // Expression : Identifier_Expression ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Expression2R1, hset);
        // Expression_Statement : ∙Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Expression_Statement0R0, hset);
        // Expression_Statement : Expression ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Expression_Statement0R1, hset);
        // Expression_Statement : Expression semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Expression_Statement0R2, hset);
        // Expression_Statement : ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Expression_Statement1R0, hset);
        // Expression_Statement : semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Expression_Statement1R1, hset);
        // For : ∙for lparen Simple_Statement Expression_Statement Expression rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_10); // for 
            fmap.insert(Label::For0R0, hset);
        // For : for ∙lparen Simple_Statement Expression_Statement Expression rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_19); // lparen 
            fmap.insert(Label::For0R1, hset);
        // For : for lparen ∙Simple_Statement Expression_Statement Expression rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For0R2, hset);
        // For : for lparen Simple_Statement ∙Expression_Statement Expression rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For0R3, hset);
        // For : for lparen Simple_Statement Expression_Statement ∙Expression rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For0R4, hset);
        // For : for lparen Simple_Statement Expression_Statement Expression ∙rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::For0R5, hset);
        // For : for lparen Simple_Statement Expression_Statement Expression rparen ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For0R6, hset);
        // For : for lparen Simple_Statement Expression_Statement Expression rparen Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For0R7, hset);
        // For : ∙for lparen Simple_Statement Expression_Statement rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_10); // for 
            fmap.insert(Label::For1R0, hset);
        // For : for ∙lparen Simple_Statement Expression_Statement rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_19); // lparen 
            fmap.insert(Label::For1R1, hset);
        // For : for lparen ∙Simple_Statement Expression_Statement rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For1R2, hset);
        // For : for lparen Simple_Statement ∙Expression_Statement rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For1R3, hset);
        // For : for lparen Simple_Statement Expression_Statement ∙rparen Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::For1R4, hset);
        // For : for lparen Simple_Statement Expression_Statement rparen ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For1R5, hset);
        // For : for lparen Simple_Statement Expression_Statement rparen Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::For1R6, hset);
        // Function_Argument : ∙identifier colon identifier 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument0R0, hset);
        // Function_Argument : identifier ∙colon identifier 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_2); // colon 
            fmap.insert(Label::Function_Argument0R1, hset);
        // Function_Argument : identifier colon ∙identifier 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument0R2, hset);
        // Function_Argument : identifier colon identifier ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_3); // comma 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument0R3, hset);
        // Function_Argument_List : ∙Function_Argument 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List0R0, hset);
        // Function_Argument_List : Function_Argument ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument_List0R1, hset);
        // Function_Argument_List : ∙Function_Argument_List_Body 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List1R0, hset);
        // Function_Argument_List : Function_Argument_List_Body ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument_List1R1, hset);
        // Function_Argument_List_Body : ∙Function_Argument comma 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List_Body0R0, hset);
        // Function_Argument_List_Body : Function_Argument ∙comma 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_3); // comma 
            fmap.insert(Label::Function_Argument_List_Body0R1, hset);
        // Function_Argument_List_Body : Function_Argument comma ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument_List_Body0R2, hset);
        // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List_Body1R0, hset);
        // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List_Body1R1, hset);
        // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument_List_Body1R2, hset);
        // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument comma 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List_Body2R0, hset);
        // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument comma 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Argument_List_Body2R1, hset);
        // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙comma 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_3); // comma 
            fmap.insert(Label::Function_Argument_List_Body2R2, hset);
        // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument comma ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Argument_List_Body2R3, hset);
        // Function_Statement : ∙function identifier lparen Function_Argument_List rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_11); // function 
            fmap.insert(Label::Function_Statement0R0, hset);
        // Function_Statement : function ∙identifier lparen Function_Argument_List rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Statement0R1, hset);
        // Function_Statement : function identifier ∙lparen Function_Argument_List rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_19); // lparen 
            fmap.insert(Label::Function_Statement0R2, hset);
        // Function_Statement : function identifier lparen ∙Function_Argument_List rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Statement0R3, hset);
        // Function_Statement : function identifier lparen Function_Argument_List ∙rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Statement0R4, hset);
        // Function_Statement : function identifier lparen Function_Argument_List rparen ∙identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Statement0R5, hset);
        // Function_Statement : function identifier lparen Function_Argument_List rparen identifier ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Function_Statement0R6, hset);
        // Function_Statement : function identifier lparen Function_Argument_List rparen identifier Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Function_Statement0R7, hset);
        // Function_Statement : ∙function identifier lparen rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_11); // function 
            fmap.insert(Label::Function_Statement1R0, hset);
        // Function_Statement : function ∙identifier lparen rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Statement1R1, hset);
        // Function_Statement : function identifier ∙lparen rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_19); // lparen 
            fmap.insert(Label::Function_Statement1R2, hset);
        // Function_Statement : function identifier lparen ∙rparen identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(Label::Function_Statement1R3, hset);
        // Function_Statement : function identifier lparen rparen ∙identifier Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Function_Statement1R4, hset);
        // Function_Statement : function identifier lparen rparen identifier ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Function_Statement1R5, hset);
        // Function_Statement : function identifier lparen rparen identifier Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Function_Statement1R6, hset);
        // GoGLL : ∙Statement_List 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::GoGLL0R0, hset);
        // GoGLL : Statement_List ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            fmap.insert(Label::GoGLL0R1, hset);
        // Identifier_Expression : ∙identifier 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Identifier_Expression0R0, hset);
        // Identifier_Expression : identifier ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Identifier_Expression0R1, hset);
        // IncDec_Expression : ∙identifier inc 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::IncDec_Expression0R0, hset);
        // IncDec_Expression : identifier ∙inc 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_15); // inc 
            fmap.insert(Label::IncDec_Expression0R1, hset);
        // IncDec_Expression : identifier inc ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::IncDec_Expression0R2, hset);
        // IncDec_Expression : ∙identifier dec 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::IncDec_Expression1R0, hset);
        // IncDec_Expression : identifier ∙dec 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_7); // dec 
            fmap.insert(Label::IncDec_Expression1R1, hset);
        // IncDec_Expression : identifier dec ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::IncDec_Expression1R2, hset);
        // Literal_Expression : ∙integer_literal 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_16); // integer_literal 
            fmap.insert(Label::Literal_Expression0R0, hset);
        // Literal_Expression : integer_literal ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Literal_Expression0R1, hset);
        // Literal_Expression : ∙float_literal 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            fmap.insert(Label::Literal_Expression1R0, hset);
        // Literal_Expression : float_literal ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Literal_Expression1R1, hset);
        // Literal_Expression : ∙string_literal 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Literal_Expression2R0, hset);
        // Literal_Expression : string_literal ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Literal_Expression2R1, hset);
        // Return_Statement : ∙return Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_21); // return 
            fmap.insert(Label::Return_Statement0R0, hset);
        // Return_Statement : return ∙Expression semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Return_Statement0R1, hset);
        // Return_Statement : return Expression ∙semicolon 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Return_Statement0R2, hset);
        // Return_Statement : return Expression semicolon ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Return_Statement0R3, hset);
        // Simple_Statement : ∙Declaration_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_18); // let 
            fmap.insert(Label::Simple_Statement0R0, hset);
        // Simple_Statement : Declaration_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Simple_Statement0R1, hset);
        // Simple_Statement : ∙Assignment_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            fmap.insert(Label::Simple_Statement1R0, hset);
        // Simple_Statement : Assignment_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Simple_Statement1R1, hset);
        // Simple_Statement : ∙Expression_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Simple_Statement2R0, hset);
        // Simple_Statement : Expression_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Simple_Statement2R1, hset);
        // Simple_Statement : ∙Empty_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Simple_Statement3R0, hset);
        // Simple_Statement : Empty_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Simple_Statement3R1, hset);
        // Statement : ∙Empty_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(Label::Statement0R0, hset);
        // Statement : Empty_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement0R1, hset);
        // Statement : ∙Simple_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement1R0, hset);
        // Statement : Simple_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement1R1, hset);
        // Statement : ∙Compound_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_17); // lbrace 
            fmap.insert(Label::Statement2R0, hset);
        // Statement : Compound_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement2R1, hset);
        // Statement : ∙Function_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_11); // function 
            fmap.insert(Label::Statement3R0, hset);
        // Statement : Function_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement3R1, hset);
        // Statement : ∙Return_Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_21); // return 
            fmap.insert(Label::Statement4R0, hset);
        // Statement : Return_Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement4R1, hset);
        // Statement : ∙For 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_10); // for 
            fmap.insert(Label::Statement5R0, hset);
        // Statement : For ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement5R1, hset);
        // Statement_List : ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement_List0R0, hset);
        // Statement_List : Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement_List0R1, hset);
        // Statement_List : ∙Statement_List Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement_List1R0, hset);
        // Statement_List : Statement_List ∙Statement 
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement_List1R1, hset);
        // Statement_List : Statement_List Statement ∙
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(Label::Statement_List1R2, hset);
        fmap
    };

    static ref FOLLOW: HashMap<NT, Box<HashSet<token::Type>>> = {
        let mut fmap = HashMap::new(); 
        // Assignment_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Assignment_Statement, hset);
        // Compound_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Compound_Statement, hset);
        // Declaration_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Declaration_Statement, hset);
        // Empty_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Empty_Statement, hset);
        // Expression
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(NT::Expression, hset);
        // Expression_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Expression_Statement, hset);
        // For
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::For, hset);
        // Function_Argument
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_3); // comma 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(NT::Function_Argument, hset);
        // Function_Argument_List
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(NT::Function_Argument_List, hset);
        // Function_Argument_List_Body
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_22); // rparen 
            fmap.insert(NT::Function_Argument_List_Body, hset);
        // Function_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Function_Statement, hset);
        // GoGLL
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            fmap.insert(NT::GoGLL, hset);
        // Identifier_Expression
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(NT::Identifier_Expression, hset);
        // IncDec_Expression
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(NT::IncDec_Expression, hset);
        // Literal_Expression
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::T_22); // rparen 
            hset.insert(token::Type::T_23); // semicolon 
            fmap.insert(NT::Literal_Expression, hset);
        // Return_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Return_Statement, hset);
        // Simple_Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Simple_Statement, hset);
        // Statement
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Statement, hset);
        // Statement_List
            let mut hset = Box::new(HashSet::new()); 
            hset.insert(token::Type::EOF); // $ 
            hset.insert(token::Type::T_9); // float_literal 
            hset.insert(token::Type::T_10); // for 
            hset.insert(token::Type::T_11); // function 
            hset.insert(token::Type::T_12); // identifier 
            hset.insert(token::Type::T_16); // integer_literal 
            hset.insert(token::Type::T_17); // lbrace 
            hset.insert(token::Type::T_18); // let 
            hset.insert(token::Type::T_20); // rbrace 
            hset.insert(token::Type::T_21); // return 
            hset.insert(token::Type::T_23); // semicolon 
            hset.insert(token::Type::T_24); // string_literal 
            fmap.insert(NT::Statement_List, hset);
        fmap
    };
}

