// Package parser is generated by gogll. Do not edit.
package parser

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"v8.run/go/conf/script/lexer"
	"v8.run/go/conf/script/parser/bsr"
	"v8.run/go/conf/script/parser/slot"
	"v8.run/go/conf/script/parser/symbols"
	"v8.run/go/conf/script/token"
)

type parser struct {
	cI int

	R *descriptors
	U *descriptors

	popped   map[poppedNode]bool
	crf      map[clusterNode][]*crfNode
	crfNodes map[crfNode]*crfNode

	lex         *lexer.Lexer
	parseErrors []*Error

	bsrSet *bsr.Set
}

func newParser(l *lexer.Lexer) *parser {
	return &parser{
		cI:     0,
		lex:    l,
		R:      &descriptors{},
		U:      &descriptors{},
		popped: make(map[poppedNode]bool),
		crf: map[clusterNode][]*crfNode{
			{symbols.NT_GoGLL, 0}: {},
		},
		crfNodes:    map[crfNode]*crfNode{},
		bsrSet:      bsr.New(symbols.NT_GoGLL, l),
		parseErrors: nil,
	}
}

// Parse returns the BSR set containing the parse forest.
// If the parse was successfull []*Error is nil
func Parse(l *lexer.Lexer) (*bsr.Set, []*Error) {
	return newParser(l).parse()
}

func (p *parser) parse() (*bsr.Set, []*Error) {
	var L slot.Label
	m, cU := len(p.lex.Tokens)-1, 0
	p.ntAdd(symbols.NT_GoGLL, 0)
	// p.DumpDescriptors()
	for !p.R.empty() {
		L, cU, p.cI = p.R.remove()

		// fmt.Println()
		// fmt.Printf("L:%s, cI:%d, I[p.cI]:%s, cU:%d\n", L, p.cI, p.lex.Tokens[p.cI], cU)
		// p.DumpDescriptors()

		switch L {
		case slot.Assignment_Statement0R0: // Assignment_Statement : ∙identifier = Expression ;

			p.bsrSet.Add(slot.Assignment_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Assignment_Statement0R1) {
				p.parseError(slot.Assignment_Statement0R1, p.cI, first[slot.Assignment_Statement0R1])
				break
			}

			p.bsrSet.Add(slot.Assignment_Statement0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Assignment_Statement0R2) {
				p.parseError(slot.Assignment_Statement0R2, p.cI, first[slot.Assignment_Statement0R2])
				break
			}

			p.call(slot.Assignment_Statement0R3, cU, p.cI)
		case slot.Assignment_Statement0R3: // Assignment_Statement : identifier = Expression ∙;

			if !p.testSelect(slot.Assignment_Statement0R3) {
				p.parseError(slot.Assignment_Statement0R3, p.cI, first[slot.Assignment_Statement0R3])
				break
			}

			p.bsrSet.Add(slot.Assignment_Statement0R4, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Assignment_Statement) {
				p.rtn(symbols.NT_Assignment_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Assignment_Statement0R0, p.cI, followSets[symbols.NT_Assignment_Statement])
			}
		case slot.Compound_Statement0R0: // Compound_Statement : ∙{ }

			p.bsrSet.Add(slot.Compound_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Compound_Statement0R1) {
				p.parseError(slot.Compound_Statement0R1, p.cI, first[slot.Compound_Statement0R1])
				break
			}

			p.bsrSet.Add(slot.Compound_Statement0R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Compound_Statement) {
				p.rtn(symbols.NT_Compound_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Compound_Statement0R0, p.cI, followSets[symbols.NT_Compound_Statement])
			}
		case slot.Compound_Statement1R0: // Compound_Statement : ∙{ Statement_List }

			p.bsrSet.Add(slot.Compound_Statement1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Compound_Statement1R1) {
				p.parseError(slot.Compound_Statement1R1, p.cI, first[slot.Compound_Statement1R1])
				break
			}

			p.call(slot.Compound_Statement1R2, cU, p.cI)
		case slot.Compound_Statement1R2: // Compound_Statement : { Statement_List ∙}

			if !p.testSelect(slot.Compound_Statement1R2) {
				p.parseError(slot.Compound_Statement1R2, p.cI, first[slot.Compound_Statement1R2])
				break
			}

			p.bsrSet.Add(slot.Compound_Statement1R3, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Compound_Statement) {
				p.rtn(symbols.NT_Compound_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Compound_Statement1R0, p.cI, followSets[symbols.NT_Compound_Statement])
			}
		case slot.Declaration_Statement0R0: // Declaration_Statement : ∙let identifier : identifier = Expression ;

			p.bsrSet.Add(slot.Declaration_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement0R1) {
				p.parseError(slot.Declaration_Statement0R1, p.cI, first[slot.Declaration_Statement0R1])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement0R2) {
				p.parseError(slot.Declaration_Statement0R2, p.cI, first[slot.Declaration_Statement0R2])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement0R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement0R3) {
				p.parseError(slot.Declaration_Statement0R3, p.cI, first[slot.Declaration_Statement0R3])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement0R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement0R4) {
				p.parseError(slot.Declaration_Statement0R4, p.cI, first[slot.Declaration_Statement0R4])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement0R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement0R5) {
				p.parseError(slot.Declaration_Statement0R5, p.cI, first[slot.Declaration_Statement0R5])
				break
			}

			p.call(slot.Declaration_Statement0R6, cU, p.cI)
		case slot.Declaration_Statement0R6: // Declaration_Statement : let identifier : identifier = Expression ∙;

			if !p.testSelect(slot.Declaration_Statement0R6) {
				p.parseError(slot.Declaration_Statement0R6, p.cI, first[slot.Declaration_Statement0R6])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement0R7, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Declaration_Statement) {
				p.rtn(symbols.NT_Declaration_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Declaration_Statement0R0, p.cI, followSets[symbols.NT_Declaration_Statement])
			}
		case slot.Declaration_Statement1R0: // Declaration_Statement : ∙let config identifier : identifier = Expression ;

			p.bsrSet.Add(slot.Declaration_Statement1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R1) {
				p.parseError(slot.Declaration_Statement1R1, p.cI, first[slot.Declaration_Statement1R1])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R2) {
				p.parseError(slot.Declaration_Statement1R2, p.cI, first[slot.Declaration_Statement1R2])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R3) {
				p.parseError(slot.Declaration_Statement1R3, p.cI, first[slot.Declaration_Statement1R3])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R4) {
				p.parseError(slot.Declaration_Statement1R4, p.cI, first[slot.Declaration_Statement1R4])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R5) {
				p.parseError(slot.Declaration_Statement1R5, p.cI, first[slot.Declaration_Statement1R5])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R6, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Declaration_Statement1R6) {
				p.parseError(slot.Declaration_Statement1R6, p.cI, first[slot.Declaration_Statement1R6])
				break
			}

			p.call(slot.Declaration_Statement1R7, cU, p.cI)
		case slot.Declaration_Statement1R7: // Declaration_Statement : let config identifier : identifier = Expression ∙;

			if !p.testSelect(slot.Declaration_Statement1R7) {
				p.parseError(slot.Declaration_Statement1R7, p.cI, first[slot.Declaration_Statement1R7])
				break
			}

			p.bsrSet.Add(slot.Declaration_Statement1R8, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Declaration_Statement) {
				p.rtn(symbols.NT_Declaration_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Declaration_Statement1R0, p.cI, followSets[symbols.NT_Declaration_Statement])
			}
		case slot.Empty_Statement0R0: // Empty_Statement : ∙;

			p.bsrSet.Add(slot.Empty_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Empty_Statement) {
				p.rtn(symbols.NT_Empty_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Empty_Statement0R0, p.cI, followSets[symbols.NT_Empty_Statement])
			}
		case slot.Expression0R0: // Expression : ∙IncDec_Expression

			p.call(slot.Expression0R1, cU, p.cI)
		case slot.Expression0R1: // Expression : IncDec_Expression ∙

			if p.follow(symbols.NT_Expression) {
				p.rtn(symbols.NT_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Expression0R0, p.cI, followSets[symbols.NT_Expression])
			}
		case slot.Expression1R0: // Expression : ∙Literal_Expression

			p.call(slot.Expression1R1, cU, p.cI)
		case slot.Expression1R1: // Expression : Literal_Expression ∙

			if p.follow(symbols.NT_Expression) {
				p.rtn(symbols.NT_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Expression1R0, p.cI, followSets[symbols.NT_Expression])
			}
		case slot.Expression2R0: // Expression : ∙Identifier_Expression

			p.call(slot.Expression2R1, cU, p.cI)
		case slot.Expression2R1: // Expression : Identifier_Expression ∙

			if p.follow(symbols.NT_Expression) {
				p.rtn(symbols.NT_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Expression2R0, p.cI, followSets[symbols.NT_Expression])
			}
		case slot.Expression_Statement0R0: // Expression_Statement : ∙Expression ;

			p.call(slot.Expression_Statement0R1, cU, p.cI)
		case slot.Expression_Statement0R1: // Expression_Statement : Expression ∙;

			if !p.testSelect(slot.Expression_Statement0R1) {
				p.parseError(slot.Expression_Statement0R1, p.cI, first[slot.Expression_Statement0R1])
				break
			}

			p.bsrSet.Add(slot.Expression_Statement0R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Expression_Statement) {
				p.rtn(symbols.NT_Expression_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Expression_Statement0R0, p.cI, followSets[symbols.NT_Expression_Statement])
			}
		case slot.Expression_Statement1R0: // Expression_Statement : ∙;

			p.bsrSet.Add(slot.Expression_Statement1R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Expression_Statement) {
				p.rtn(symbols.NT_Expression_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Expression_Statement1R0, p.cI, followSets[symbols.NT_Expression_Statement])
			}
		case slot.For0R0: // For : ∙for ( Simple_Statement Expression_Statement Expression ) Statement

			p.bsrSet.Add(slot.For0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For0R1) {
				p.parseError(slot.For0R1, p.cI, first[slot.For0R1])
				break
			}

			p.bsrSet.Add(slot.For0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For0R2) {
				p.parseError(slot.For0R2, p.cI, first[slot.For0R2])
				break
			}

			p.call(slot.For0R3, cU, p.cI)
		case slot.For0R3: // For : for ( Simple_Statement ∙Expression_Statement Expression ) Statement

			if !p.testSelect(slot.For0R3) {
				p.parseError(slot.For0R3, p.cI, first[slot.For0R3])
				break
			}

			p.call(slot.For0R4, cU, p.cI)
		case slot.For0R4: // For : for ( Simple_Statement Expression_Statement ∙Expression ) Statement

			if !p.testSelect(slot.For0R4) {
				p.parseError(slot.For0R4, p.cI, first[slot.For0R4])
				break
			}

			p.call(slot.For0R5, cU, p.cI)
		case slot.For0R5: // For : for ( Simple_Statement Expression_Statement Expression ∙) Statement

			if !p.testSelect(slot.For0R5) {
				p.parseError(slot.For0R5, p.cI, first[slot.For0R5])
				break
			}

			p.bsrSet.Add(slot.For0R6, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For0R6) {
				p.parseError(slot.For0R6, p.cI, first[slot.For0R6])
				break
			}

			p.call(slot.For0R7, cU, p.cI)
		case slot.For0R7: // For : for ( Simple_Statement Expression_Statement Expression ) Statement ∙

			if p.follow(symbols.NT_For) {
				p.rtn(symbols.NT_For, cU, p.cI)
			} else {
				p.parseError(slot.For0R0, p.cI, followSets[symbols.NT_For])
			}
		case slot.For1R0: // For : ∙for ( Simple_Statement Expression_Statement ) Statement

			p.bsrSet.Add(slot.For1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For1R1) {
				p.parseError(slot.For1R1, p.cI, first[slot.For1R1])
				break
			}

			p.bsrSet.Add(slot.For1R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For1R2) {
				p.parseError(slot.For1R2, p.cI, first[slot.For1R2])
				break
			}

			p.call(slot.For1R3, cU, p.cI)
		case slot.For1R3: // For : for ( Simple_Statement ∙Expression_Statement ) Statement

			if !p.testSelect(slot.For1R3) {
				p.parseError(slot.For1R3, p.cI, first[slot.For1R3])
				break
			}

			p.call(slot.For1R4, cU, p.cI)
		case slot.For1R4: // For : for ( Simple_Statement Expression_Statement ∙) Statement

			if !p.testSelect(slot.For1R4) {
				p.parseError(slot.For1R4, p.cI, first[slot.For1R4])
				break
			}

			p.bsrSet.Add(slot.For1R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.For1R5) {
				p.parseError(slot.For1R5, p.cI, first[slot.For1R5])
				break
			}

			p.call(slot.For1R6, cU, p.cI)
		case slot.For1R6: // For : for ( Simple_Statement Expression_Statement ) Statement ∙

			if p.follow(symbols.NT_For) {
				p.rtn(symbols.NT_For, cU, p.cI)
			} else {
				p.parseError(slot.For1R0, p.cI, followSets[symbols.NT_For])
			}
		case slot.Function_Argument0R0: // Function_Argument : ∙identifier : identifier

			p.bsrSet.Add(slot.Function_Argument0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Argument0R1) {
				p.parseError(slot.Function_Argument0R1, p.cI, first[slot.Function_Argument0R1])
				break
			}

			p.bsrSet.Add(slot.Function_Argument0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Argument0R2) {
				p.parseError(slot.Function_Argument0R2, p.cI, first[slot.Function_Argument0R2])
				break
			}

			p.bsrSet.Add(slot.Function_Argument0R3, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Function_Argument) {
				p.rtn(symbols.NT_Function_Argument, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument0R0, p.cI, followSets[symbols.NT_Function_Argument])
			}
		case slot.Function_Argument_List0R0: // Function_Argument_List : ∙Function_Argument

			p.call(slot.Function_Argument_List0R1, cU, p.cI)
		case slot.Function_Argument_List0R1: // Function_Argument_List : Function_Argument ∙

			if p.follow(symbols.NT_Function_Argument_List) {
				p.rtn(symbols.NT_Function_Argument_List, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument_List0R0, p.cI, followSets[symbols.NT_Function_Argument_List])
			}
		case slot.Function_Argument_List1R0: // Function_Argument_List : ∙Function_Argument_List_Body

			p.call(slot.Function_Argument_List1R1, cU, p.cI)
		case slot.Function_Argument_List1R1: // Function_Argument_List : Function_Argument_List_Body ∙

			if p.follow(symbols.NT_Function_Argument_List) {
				p.rtn(symbols.NT_Function_Argument_List, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument_List1R0, p.cI, followSets[symbols.NT_Function_Argument_List])
			}
		case slot.Function_Argument_List_Body0R0: // Function_Argument_List_Body : ∙Function_Argument ;

			p.call(slot.Function_Argument_List_Body0R1, cU, p.cI)
		case slot.Function_Argument_List_Body0R1: // Function_Argument_List_Body : Function_Argument ∙;

			if !p.testSelect(slot.Function_Argument_List_Body0R1) {
				p.parseError(slot.Function_Argument_List_Body0R1, p.cI, first[slot.Function_Argument_List_Body0R1])
				break
			}

			p.bsrSet.Add(slot.Function_Argument_List_Body0R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Function_Argument_List_Body) {
				p.rtn(symbols.NT_Function_Argument_List_Body, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument_List_Body0R0, p.cI, followSets[symbols.NT_Function_Argument_List_Body])
			}
		case slot.Function_Argument_List_Body1R0: // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument

			p.call(slot.Function_Argument_List_Body1R1, cU, p.cI)
		case slot.Function_Argument_List_Body1R1: // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument

			if !p.testSelect(slot.Function_Argument_List_Body1R1) {
				p.parseError(slot.Function_Argument_List_Body1R1, p.cI, first[slot.Function_Argument_List_Body1R1])
				break
			}

			p.call(slot.Function_Argument_List_Body1R2, cU, p.cI)
		case slot.Function_Argument_List_Body1R2: // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙

			if p.follow(symbols.NT_Function_Argument_List_Body) {
				p.rtn(symbols.NT_Function_Argument_List_Body, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument_List_Body1R0, p.cI, followSets[symbols.NT_Function_Argument_List_Body])
			}
		case slot.Function_Argument_List_Body2R0: // Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument ;

			p.call(slot.Function_Argument_List_Body2R1, cU, p.cI)
		case slot.Function_Argument_List_Body2R1: // Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument ;

			if !p.testSelect(slot.Function_Argument_List_Body2R1) {
				p.parseError(slot.Function_Argument_List_Body2R1, p.cI, first[slot.Function_Argument_List_Body2R1])
				break
			}

			p.call(slot.Function_Argument_List_Body2R2, cU, p.cI)
		case slot.Function_Argument_List_Body2R2: // Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙;

			if !p.testSelect(slot.Function_Argument_List_Body2R2) {
				p.parseError(slot.Function_Argument_List_Body2R2, p.cI, first[slot.Function_Argument_List_Body2R2])
				break
			}

			p.bsrSet.Add(slot.Function_Argument_List_Body2R3, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Function_Argument_List_Body) {
				p.rtn(symbols.NT_Function_Argument_List_Body, cU, p.cI)
			} else {
				p.parseError(slot.Function_Argument_List_Body2R0, p.cI, followSets[symbols.NT_Function_Argument_List_Body])
			}
		case slot.Function_Statement0R0: // Function_Statement : ∙func identifier ( Function_Argument_List ) identifier Statement

			p.bsrSet.Add(slot.Function_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement0R1) {
				p.parseError(slot.Function_Statement0R1, p.cI, first[slot.Function_Statement0R1])
				break
			}

			p.bsrSet.Add(slot.Function_Statement0R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement0R2) {
				p.parseError(slot.Function_Statement0R2, p.cI, first[slot.Function_Statement0R2])
				break
			}

			p.bsrSet.Add(slot.Function_Statement0R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement0R3) {
				p.parseError(slot.Function_Statement0R3, p.cI, first[slot.Function_Statement0R3])
				break
			}

			p.call(slot.Function_Statement0R4, cU, p.cI)
		case slot.Function_Statement0R4: // Function_Statement : func identifier ( Function_Argument_List ∙) identifier Statement

			if !p.testSelect(slot.Function_Statement0R4) {
				p.parseError(slot.Function_Statement0R4, p.cI, first[slot.Function_Statement0R4])
				break
			}

			p.bsrSet.Add(slot.Function_Statement0R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement0R5) {
				p.parseError(slot.Function_Statement0R5, p.cI, first[slot.Function_Statement0R5])
				break
			}

			p.bsrSet.Add(slot.Function_Statement0R6, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement0R6) {
				p.parseError(slot.Function_Statement0R6, p.cI, first[slot.Function_Statement0R6])
				break
			}

			p.call(slot.Function_Statement0R7, cU, p.cI)
		case slot.Function_Statement0R7: // Function_Statement : func identifier ( Function_Argument_List ) identifier Statement ∙

			if p.follow(symbols.NT_Function_Statement) {
				p.rtn(symbols.NT_Function_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Function_Statement0R0, p.cI, followSets[symbols.NT_Function_Statement])
			}
		case slot.Function_Statement1R0: // Function_Statement : ∙func identifier ( ) identifier Statement

			p.bsrSet.Add(slot.Function_Statement1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement1R1) {
				p.parseError(slot.Function_Statement1R1, p.cI, first[slot.Function_Statement1R1])
				break
			}

			p.bsrSet.Add(slot.Function_Statement1R2, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement1R2) {
				p.parseError(slot.Function_Statement1R2, p.cI, first[slot.Function_Statement1R2])
				break
			}

			p.bsrSet.Add(slot.Function_Statement1R3, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement1R3) {
				p.parseError(slot.Function_Statement1R3, p.cI, first[slot.Function_Statement1R3])
				break
			}

			p.bsrSet.Add(slot.Function_Statement1R4, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement1R4) {
				p.parseError(slot.Function_Statement1R4, p.cI, first[slot.Function_Statement1R4])
				break
			}

			p.bsrSet.Add(slot.Function_Statement1R5, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Function_Statement1R5) {
				p.parseError(slot.Function_Statement1R5, p.cI, first[slot.Function_Statement1R5])
				break
			}

			p.call(slot.Function_Statement1R6, cU, p.cI)
		case slot.Function_Statement1R6: // Function_Statement : func identifier ( ) identifier Statement ∙

			if p.follow(symbols.NT_Function_Statement) {
				p.rtn(symbols.NT_Function_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Function_Statement1R0, p.cI, followSets[symbols.NT_Function_Statement])
			}
		case slot.GoGLL0R0: // GoGLL : ∙Statement_List

			p.call(slot.GoGLL0R1, cU, p.cI)
		case slot.GoGLL0R1: // GoGLL : Statement_List ∙

			if p.follow(symbols.NT_GoGLL) {
				p.rtn(symbols.NT_GoGLL, cU, p.cI)
			} else {
				p.parseError(slot.GoGLL0R0, p.cI, followSets[symbols.NT_GoGLL])
			}
		case slot.Identifier_Expression0R0: // Identifier_Expression : ∙identifier

			p.bsrSet.Add(slot.Identifier_Expression0R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Identifier_Expression) {
				p.rtn(symbols.NT_Identifier_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Identifier_Expression0R0, p.cI, followSets[symbols.NT_Identifier_Expression])
			}
		case slot.IncDec_Expression0R0: // IncDec_Expression : ∙identifier ++

			p.bsrSet.Add(slot.IncDec_Expression0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.IncDec_Expression0R1) {
				p.parseError(slot.IncDec_Expression0R1, p.cI, first[slot.IncDec_Expression0R1])
				break
			}

			p.bsrSet.Add(slot.IncDec_Expression0R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_IncDec_Expression) {
				p.rtn(symbols.NT_IncDec_Expression, cU, p.cI)
			} else {
				p.parseError(slot.IncDec_Expression0R0, p.cI, followSets[symbols.NT_IncDec_Expression])
			}
		case slot.IncDec_Expression1R0: // IncDec_Expression : ∙identifier --

			p.bsrSet.Add(slot.IncDec_Expression1R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.IncDec_Expression1R1) {
				p.parseError(slot.IncDec_Expression1R1, p.cI, first[slot.IncDec_Expression1R1])
				break
			}

			p.bsrSet.Add(slot.IncDec_Expression1R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_IncDec_Expression) {
				p.rtn(symbols.NT_IncDec_Expression, cU, p.cI)
			} else {
				p.parseError(slot.IncDec_Expression1R0, p.cI, followSets[symbols.NT_IncDec_Expression])
			}
		case slot.IncDec_Expression2R0: // IncDec_Expression : ∙++ identifier

			p.bsrSet.Add(slot.IncDec_Expression2R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.IncDec_Expression2R1) {
				p.parseError(slot.IncDec_Expression2R1, p.cI, first[slot.IncDec_Expression2R1])
				break
			}

			p.bsrSet.Add(slot.IncDec_Expression2R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_IncDec_Expression) {
				p.rtn(symbols.NT_IncDec_Expression, cU, p.cI)
			} else {
				p.parseError(slot.IncDec_Expression2R0, p.cI, followSets[symbols.NT_IncDec_Expression])
			}
		case slot.IncDec_Expression3R0: // IncDec_Expression : ∙-- identifier

			p.bsrSet.Add(slot.IncDec_Expression3R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.IncDec_Expression3R1) {
				p.parseError(slot.IncDec_Expression3R1, p.cI, first[slot.IncDec_Expression3R1])
				break
			}

			p.bsrSet.Add(slot.IncDec_Expression3R2, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_IncDec_Expression) {
				p.rtn(symbols.NT_IncDec_Expression, cU, p.cI)
			} else {
				p.parseError(slot.IncDec_Expression3R0, p.cI, followSets[symbols.NT_IncDec_Expression])
			}
		case slot.Literal_Expression0R0: // Literal_Expression : ∙integer_literal

			p.bsrSet.Add(slot.Literal_Expression0R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Literal_Expression) {
				p.rtn(symbols.NT_Literal_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Literal_Expression0R0, p.cI, followSets[symbols.NT_Literal_Expression])
			}
		case slot.Literal_Expression1R0: // Literal_Expression : ∙float_literal

			p.bsrSet.Add(slot.Literal_Expression1R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Literal_Expression) {
				p.rtn(symbols.NT_Literal_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Literal_Expression1R0, p.cI, followSets[symbols.NT_Literal_Expression])
			}
		case slot.Literal_Expression2R0: // Literal_Expression : ∙string_literal

			p.bsrSet.Add(slot.Literal_Expression2R1, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Literal_Expression) {
				p.rtn(symbols.NT_Literal_Expression, cU, p.cI)
			} else {
				p.parseError(slot.Literal_Expression2R0, p.cI, followSets[symbols.NT_Literal_Expression])
			}
		case slot.Return_Statement0R0: // Return_Statement : ∙return Expression ;

			p.bsrSet.Add(slot.Return_Statement0R1, cU, p.cI, p.cI+1)
			p.cI++
			if !p.testSelect(slot.Return_Statement0R1) {
				p.parseError(slot.Return_Statement0R1, p.cI, first[slot.Return_Statement0R1])
				break
			}

			p.call(slot.Return_Statement0R2, cU, p.cI)
		case slot.Return_Statement0R2: // Return_Statement : return Expression ∙;

			if !p.testSelect(slot.Return_Statement0R2) {
				p.parseError(slot.Return_Statement0R2, p.cI, first[slot.Return_Statement0R2])
				break
			}

			p.bsrSet.Add(slot.Return_Statement0R3, cU, p.cI, p.cI+1)
			p.cI++
			if p.follow(symbols.NT_Return_Statement) {
				p.rtn(symbols.NT_Return_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Return_Statement0R0, p.cI, followSets[symbols.NT_Return_Statement])
			}
		case slot.Simple_Statement0R0: // Simple_Statement : ∙Declaration_Statement

			p.call(slot.Simple_Statement0R1, cU, p.cI)
		case slot.Simple_Statement0R1: // Simple_Statement : Declaration_Statement ∙

			if p.follow(symbols.NT_Simple_Statement) {
				p.rtn(symbols.NT_Simple_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Simple_Statement0R0, p.cI, followSets[symbols.NT_Simple_Statement])
			}
		case slot.Simple_Statement1R0: // Simple_Statement : ∙Assignment_Statement

			p.call(slot.Simple_Statement1R1, cU, p.cI)
		case slot.Simple_Statement1R1: // Simple_Statement : Assignment_Statement ∙

			if p.follow(symbols.NT_Simple_Statement) {
				p.rtn(symbols.NT_Simple_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Simple_Statement1R0, p.cI, followSets[symbols.NT_Simple_Statement])
			}
		case slot.Simple_Statement2R0: // Simple_Statement : ∙Expression_Statement

			p.call(slot.Simple_Statement2R1, cU, p.cI)
		case slot.Simple_Statement2R1: // Simple_Statement : Expression_Statement ∙

			if p.follow(symbols.NT_Simple_Statement) {
				p.rtn(symbols.NT_Simple_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Simple_Statement2R0, p.cI, followSets[symbols.NT_Simple_Statement])
			}
		case slot.Simple_Statement3R0: // Simple_Statement : ∙Empty_Statement

			p.call(slot.Simple_Statement3R1, cU, p.cI)
		case slot.Simple_Statement3R1: // Simple_Statement : Empty_Statement ∙

			if p.follow(symbols.NT_Simple_Statement) {
				p.rtn(symbols.NT_Simple_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Simple_Statement3R0, p.cI, followSets[symbols.NT_Simple_Statement])
			}
		case slot.Statement0R0: // Statement : ∙Empty_Statement

			p.call(slot.Statement0R1, cU, p.cI)
		case slot.Statement0R1: // Statement : Empty_Statement ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement0R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement1R0: // Statement : ∙Simple_Statement

			p.call(slot.Statement1R1, cU, p.cI)
		case slot.Statement1R1: // Statement : Simple_Statement ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement1R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement2R0: // Statement : ∙Compound_Statement

			p.call(slot.Statement2R1, cU, p.cI)
		case slot.Statement2R1: // Statement : Compound_Statement ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement2R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement3R0: // Statement : ∙Function_Statement

			p.call(slot.Statement3R1, cU, p.cI)
		case slot.Statement3R1: // Statement : Function_Statement ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement3R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement4R0: // Statement : ∙Return_Statement

			p.call(slot.Statement4R1, cU, p.cI)
		case slot.Statement4R1: // Statement : Return_Statement ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement4R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement5R0: // Statement : ∙For

			p.call(slot.Statement5R1, cU, p.cI)
		case slot.Statement5R1: // Statement : For ∙

			if p.follow(symbols.NT_Statement) {
				p.rtn(symbols.NT_Statement, cU, p.cI)
			} else {
				p.parseError(slot.Statement5R0, p.cI, followSets[symbols.NT_Statement])
			}
		case slot.Statement_List0R0: // Statement_List : ∙Statement

			p.call(slot.Statement_List0R1, cU, p.cI)
		case slot.Statement_List0R1: // Statement_List : Statement ∙

			if p.follow(symbols.NT_Statement_List) {
				p.rtn(symbols.NT_Statement_List, cU, p.cI)
			} else {
				p.parseError(slot.Statement_List0R0, p.cI, followSets[symbols.NT_Statement_List])
			}
		case slot.Statement_List1R0: // Statement_List : ∙Statement_List Statement

			p.call(slot.Statement_List1R1, cU, p.cI)
		case slot.Statement_List1R1: // Statement_List : Statement_List ∙Statement

			if !p.testSelect(slot.Statement_List1R1) {
				p.parseError(slot.Statement_List1R1, p.cI, first[slot.Statement_List1R1])
				break
			}

			p.call(slot.Statement_List1R2, cU, p.cI)
		case slot.Statement_List1R2: // Statement_List : Statement_List Statement ∙

			if p.follow(symbols.NT_Statement_List) {
				p.rtn(symbols.NT_Statement_List, cU, p.cI)
			} else {
				p.parseError(slot.Statement_List1R0, p.cI, followSets[symbols.NT_Statement_List])
			}

		default:
			panic("This must not happen")
		}
	}
	if !p.bsrSet.Contain(symbols.NT_GoGLL, 0, m) {
		p.sortParseErrors()
		return nil, p.parseErrors
	}
	return p.bsrSet, nil
}

func (p *parser) ntAdd(nt symbols.NT, j int) {
	// fmt.Printf("p.ntAdd(%s, %d)\n", nt, j)
	failed := true
	expected := map[token.Type]string{}
	for _, l := range slot.GetAlternates(nt) {
		if p.testSelect(l) {
			p.dscAdd(l, j, j)
			failed = false
		} else {
			for k, v := range first[l] {
				expected[k] = v
			}
		}
	}
	if failed {
		for _, l := range slot.GetAlternates(nt) {
			p.parseError(l, j, expected)
		}
	}
}

/*** Call Return Forest ***/

type poppedNode struct {
	X    symbols.NT
	k, j int
}

type clusterNode struct {
	X symbols.NT
	k int
}

type crfNode struct {
	L slot.Label
	i int
}

/*
suppose that L is Y ::=αX ·β
if there is no CRF node labelled (L,i)

	create one let u be the CRF node labelled (L,i)

if there is no CRF node labelled (X, j) {

		create a CRF node v labelled (X, j)
		create an edge from v to u
		ntAdd(X, j)
	} else {

		let v be the CRF node labelled (X, j)
		if there is not an edge from v to u {
			create an edge from v to u
			for all ((X, j,h)∈P) {
				dscAdd(L, i, h);
				bsrAdd(L, i, j, h)
			}
		}
	}
*/
func (p *parser) call(L slot.Label, i, j int) {
	// fmt.Printf("p.call(%s,%d,%d)\n", L,i,j)
	u, exist := p.crfNodes[crfNode{L, i}]
	// fmt.Printf("  u exist=%t\n", exist)
	if !exist {
		u = &crfNode{L, i}
		p.crfNodes[*u] = u
	}
	X := L.Symbols()[L.Pos()-1].(symbols.NT)
	ndV := clusterNode{X, j}
	v, exist := p.crf[ndV]
	if !exist {
		// fmt.Println("  v !exist")
		p.crf[ndV] = []*crfNode{u}
		p.ntAdd(X, j)
	} else {
		// fmt.Println("  v exist")
		if !existEdge(v, u) {
			// fmt.Printf("  !existEdge(%v)\n", u)
			p.crf[ndV] = append(v, u)
			// fmt.Printf("|popped|=%d\n", len(popped))
			for pnd := range p.popped {
				if pnd.X == X && pnd.k == j {
					p.dscAdd(L, i, pnd.j)
					p.bsrSet.Add(L, i, j, pnd.j)
				}
			}
		}
	}
}

func existEdge(nds []*crfNode, nd *crfNode) bool {
	for _, nd1 := range nds {
		if nd1 == nd {
			return true
		}
	}
	return false
}

func (p *parser) rtn(X symbols.NT, k, j int) {
	// fmt.Printf("p.rtn(%s,%d,%d)\n", X,k,j)
	pn := poppedNode{X, k, j}
	if _, exist := p.popped[pn]; !exist {
		p.popped[pn] = true
		for _, nd := range p.crf[clusterNode{X, k}] {
			p.dscAdd(nd.L, nd.i, j)
			p.bsrSet.Add(nd.L, nd.i, k, j)
		}
	}
}

// func CRFString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("CRF: {")
// 	for cn, nds := range crf{
// 		for _, nd := range nds {
// 			fmt.Fprintf(buf, "%s->%s, ", cn, nd)
// 		}
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

func (cn clusterNode) String() string {
	return fmt.Sprintf("(%s,%d)", cn.X, cn.k)
}

func (n crfNode) String() string {
	return fmt.Sprintf("(%s,%d)", n.L.String(), n.i)
}

// func PoppedString() string {
// 	buf := new(bytes.Buffer)
// 	buf.WriteString("Popped: {")
// 	for p, _ := range popped {
// 		fmt.Fprintf(buf, "(%s,%d,%d) ", p.X, p.k, p.j)
// 	}
// 	buf.WriteString("}")
// 	return buf.String()
// }

/*** descriptors ***/

type descriptors struct {
	set []*descriptor
}

func (ds *descriptors) contain(d *descriptor) bool {
	for _, d1 := range ds.set {
		if d1 == d {
			return true
		}
	}
	return false
}

func (ds *descriptors) empty() bool {
	return len(ds.set) == 0
}

func (ds *descriptors) String() string {
	buf := new(bytes.Buffer)
	buf.WriteString("{")
	for i, d := range ds.set {
		if i > 0 {
			buf.WriteString("; ")
		}
		fmt.Fprintf(buf, "%s", d)
	}
	buf.WriteString("}")
	return buf.String()
}

type descriptor struct {
	L slot.Label
	k int
	i int
}

func (d *descriptor) String() string {
	return fmt.Sprintf("%s,%d,%d", d.L, d.k, d.i)
}

func (p *parser) dscAdd(L slot.Label, k, i int) {
	// fmt.Printf("p.dscAdd(%s,%d,%d)\n", L, k, i)
	d := &descriptor{L, k, i}
	if !p.U.contain(d) {
		p.R.set = append(p.R.set, d)
		p.U.set = append(p.U.set, d)
	}
}

func (ds *descriptors) remove() (L slot.Label, k, i int) {
	d := ds.set[len(ds.set)-1]
	ds.set = ds.set[:len(ds.set)-1]
	// fmt.Printf("remove: %s,%d,%d\n", d.L, d.k, d.i)
	return d.L, d.k, d.i
}

func (p *parser) DumpDescriptors() {
	p.DumpR()
	p.DumpU()
}

func (p *parser) DumpR() {
	fmt.Println("R:")
	for _, d := range p.R.set {
		fmt.Printf(" %s\n", d)
	}
}

func (p *parser) DumpU() {
	fmt.Println("U:")
	for _, d := range p.U.set {
		fmt.Printf(" %s\n", d)
	}
}

/*** TestSelect ***/

func (p *parser) follow(nt symbols.NT) bool {
	_, exist := followSets[nt][p.lex.Tokens[p.cI].Type()]
	return exist
}

func (p *parser) testSelect(l slot.Label) bool {
	_, exist := first[l][p.lex.Tokens[p.cI].Type()]
	// fmt.Printf("testSelect(%s) = %t\n", l, exist)
	return exist
}

var first = []map[token.Type]string{
	// Assignment_Statement : ∙identifier = Expression ;
	{
		token.T_12: "identifier",
	},
	// Assignment_Statement : identifier ∙= Expression ;
	{
		token.T_6: "=",
	},
	// Assignment_Statement : identifier = ∙Expression ;
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Assignment_Statement : identifier = Expression ∙;
	{
		token.T_5: ";",
	},
	// Assignment_Statement : identifier = Expression ; ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Compound_Statement : ∙{ }
	{
		token.T_17: "{",
	},
	// Compound_Statement : { ∙}
	{
		token.T_18: "}",
	},
	// Compound_Statement : { } ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Compound_Statement : ∙{ Statement_List }
	{
		token.T_17: "{",
	},
	// Compound_Statement : { ∙Statement_List }
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Compound_Statement : { Statement_List ∙}
	{
		token.T_18: "}",
	},
	// Compound_Statement : { Statement_List } ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Declaration_Statement : ∙let identifier : identifier = Expression ;
	{
		token.T_14: "let",
	},
	// Declaration_Statement : let ∙identifier : identifier = Expression ;
	{
		token.T_12: "identifier",
	},
	// Declaration_Statement : let identifier ∙: identifier = Expression ;
	{
		token.T_4: ":",
	},
	// Declaration_Statement : let identifier : ∙identifier = Expression ;
	{
		token.T_12: "identifier",
	},
	// Declaration_Statement : let identifier : identifier ∙= Expression ;
	{
		token.T_6: "=",
	},
	// Declaration_Statement : let identifier : identifier = ∙Expression ;
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Declaration_Statement : let identifier : identifier = Expression ∙;
	{
		token.T_5: ";",
	},
	// Declaration_Statement : let identifier : identifier = Expression ; ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Declaration_Statement : ∙let config identifier : identifier = Expression ;
	{
		token.T_14: "let",
	},
	// Declaration_Statement : let ∙config identifier : identifier = Expression ;
	{
		token.T_8: "config",
	},
	// Declaration_Statement : let config ∙identifier : identifier = Expression ;
	{
		token.T_12: "identifier",
	},
	// Declaration_Statement : let config identifier ∙: identifier = Expression ;
	{
		token.T_4: ":",
	},
	// Declaration_Statement : let config identifier : ∙identifier = Expression ;
	{
		token.T_12: "identifier",
	},
	// Declaration_Statement : let config identifier : identifier ∙= Expression ;
	{
		token.T_6: "=",
	},
	// Declaration_Statement : let config identifier : identifier = ∙Expression ;
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Declaration_Statement : let config identifier : identifier = Expression ∙;
	{
		token.T_5: ";",
	},
	// Declaration_Statement : let config identifier : identifier = Expression ; ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Empty_Statement : ∙;
	{
		token.T_5: ";",
	},
	// Empty_Statement : ; ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Expression : ∙IncDec_Expression
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_12: "identifier",
	},
	// Expression : IncDec_Expression ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Expression : ∙Literal_Expression
	{
		token.T_9:  "float_literal",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Expression : Literal_Expression ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Expression : ∙Identifier_Expression
	{
		token.T_12: "identifier",
	},
	// Expression : Identifier_Expression ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Expression_Statement : ∙Expression ;
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Expression_Statement : Expression ∙;
	{
		token.T_5: ";",
	},
	// Expression_Statement : Expression ; ∙
	{
		token.EOF:  "$",
		token.T_1:  ")",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Expression_Statement : ∙;
	{
		token.T_5: ";",
	},
	// Expression_Statement : ; ∙
	{
		token.EOF:  "$",
		token.T_1:  ")",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// For : ∙for ( Simple_Statement Expression_Statement Expression ) Statement
	{
		token.T_10: "for",
	},
	// For : for ∙( Simple_Statement Expression_Statement Expression ) Statement
	{
		token.T_0: "(",
	},
	// For : for ( ∙Simple_Statement Expression_Statement Expression ) Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_16: "string_literal",
	},
	// For : for ( Simple_Statement ∙Expression_Statement Expression ) Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// For : for ( Simple_Statement Expression_Statement ∙Expression ) Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// For : for ( Simple_Statement Expression_Statement Expression ∙) Statement
	{
		token.T_1: ")",
	},
	// For : for ( Simple_Statement Expression_Statement Expression ) ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// For : for ( Simple_Statement Expression_Statement Expression ) Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// For : ∙for ( Simple_Statement Expression_Statement ) Statement
	{
		token.T_10: "for",
	},
	// For : for ∙( Simple_Statement Expression_Statement ) Statement
	{
		token.T_0: "(",
	},
	// For : for ( ∙Simple_Statement Expression_Statement ) Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_16: "string_literal",
	},
	// For : for ( Simple_Statement ∙Expression_Statement ) Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// For : for ( Simple_Statement Expression_Statement ∙) Statement
	{
		token.T_1: ")",
	},
	// For : for ( Simple_Statement Expression_Statement ) ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// For : for ( Simple_Statement Expression_Statement ) Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Function_Argument : ∙identifier : identifier
	{
		token.T_12: "identifier",
	},
	// Function_Argument : identifier ∙: identifier
	{
		token.T_4: ":",
	},
	// Function_Argument : identifier : ∙identifier
	{
		token.T_12: "identifier",
	},
	// Function_Argument : identifier : identifier ∙
	{
		token.T_1:  ")",
		token.T_5:  ";",
		token.T_12: "identifier",
	},
	// Function_Argument_List : ∙Function_Argument
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List : Function_Argument ∙
	{
		token.T_1: ")",
	},
	// Function_Argument_List : ∙Function_Argument_List_Body
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List : Function_Argument_List_Body ∙
	{
		token.T_1: ")",
	},
	// Function_Argument_List_Body : ∙Function_Argument ;
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : Function_Argument ∙;
	{
		token.T_5: ";",
	},
	// Function_Argument_List_Body : Function_Argument ; ∙
	{
		token.T_1:  ")",
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙
	{
		token.T_1:  ")",
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : ∙Function_Argument_List_Body Function_Argument ;
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : Function_Argument_List_Body ∙Function_Argument ;
	{
		token.T_12: "identifier",
	},
	// Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ∙;
	{
		token.T_5: ";",
	},
	// Function_Argument_List_Body : Function_Argument_List_Body Function_Argument ; ∙
	{
		token.T_1:  ")",
		token.T_12: "identifier",
	},
	// Function_Statement : ∙func identifier ( Function_Argument_List ) identifier Statement
	{
		token.T_11: "func",
	},
	// Function_Statement : func ∙identifier ( Function_Argument_List ) identifier Statement
	{
		token.T_12: "identifier",
	},
	// Function_Statement : func identifier ∙( Function_Argument_List ) identifier Statement
	{
		token.T_0: "(",
	},
	// Function_Statement : func identifier ( ∙Function_Argument_List ) identifier Statement
	{
		token.T_12: "identifier",
	},
	// Function_Statement : func identifier ( Function_Argument_List ∙) identifier Statement
	{
		token.T_1: ")",
	},
	// Function_Statement : func identifier ( Function_Argument_List ) ∙identifier Statement
	{
		token.T_12: "identifier",
	},
	// Function_Statement : func identifier ( Function_Argument_List ) identifier ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Function_Statement : func identifier ( Function_Argument_List ) identifier Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Function_Statement : ∙func identifier ( ) identifier Statement
	{
		token.T_11: "func",
	},
	// Function_Statement : func ∙identifier ( ) identifier Statement
	{
		token.T_12: "identifier",
	},
	// Function_Statement : func identifier ∙( ) identifier Statement
	{
		token.T_0: "(",
	},
	// Function_Statement : func identifier ( ∙) identifier Statement
	{
		token.T_1: ")",
	},
	// Function_Statement : func identifier ( ) ∙identifier Statement
	{
		token.T_12: "identifier",
	},
	// Function_Statement : func identifier ( ) identifier ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Function_Statement : func identifier ( ) identifier Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// GoGLL : ∙Statement_List
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// GoGLL : Statement_List ∙
	{
		token.EOF: "$",
	},
	// Identifier_Expression : ∙identifier
	{
		token.T_12: "identifier",
	},
	// Identifier_Expression : identifier ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// IncDec_Expression : ∙identifier ++
	{
		token.T_12: "identifier",
	},
	// IncDec_Expression : identifier ∙++
	{
		token.T_2: "++",
	},
	// IncDec_Expression : identifier ++ ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// IncDec_Expression : ∙identifier --
	{
		token.T_12: "identifier",
	},
	// IncDec_Expression : identifier ∙--
	{
		token.T_3: "--",
	},
	// IncDec_Expression : identifier -- ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// IncDec_Expression : ∙++ identifier
	{
		token.T_2: "++",
	},
	// IncDec_Expression : ++ ∙identifier
	{
		token.T_12: "identifier",
	},
	// IncDec_Expression : ++ identifier ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// IncDec_Expression : ∙-- identifier
	{
		token.T_3: "--",
	},
	// IncDec_Expression : -- ∙identifier
	{
		token.T_12: "identifier",
	},
	// IncDec_Expression : -- identifier ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Literal_Expression : ∙integer_literal
	{
		token.T_13: "integer_literal",
	},
	// Literal_Expression : integer_literal ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Literal_Expression : ∙float_literal
	{
		token.T_9: "float_literal",
	},
	// Literal_Expression : float_literal ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Literal_Expression : ∙string_literal
	{
		token.T_16: "string_literal",
	},
	// Literal_Expression : string_literal ∙
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Return_Statement : ∙return Expression ;
	{
		token.T_15: "return",
	},
	// Return_Statement : return ∙Expression ;
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Return_Statement : return Expression ∙;
	{
		token.T_5: ";",
	},
	// Return_Statement : return Expression ; ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Simple_Statement : ∙Declaration_Statement
	{
		token.T_14: "let",
	},
	// Simple_Statement : Declaration_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Simple_Statement : ∙Assignment_Statement
	{
		token.T_12: "identifier",
	},
	// Simple_Statement : Assignment_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Simple_Statement : ∙Expression_Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_16: "string_literal",
	},
	// Simple_Statement : Expression_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Simple_Statement : ∙Empty_Statement
	{
		token.T_5: ";",
	},
	// Simple_Statement : Empty_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙Empty_Statement
	{
		token.T_5: ";",
	},
	// Statement : Empty_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙Simple_Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_16: "string_literal",
	},
	// Statement : Simple_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙Compound_Statement
	{
		token.T_17: "{",
	},
	// Statement : Compound_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙Function_Statement
	{
		token.T_11: "func",
	},
	// Statement : Function_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙Return_Statement
	{
		token.T_15: "return",
	},
	// Statement : Return_Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement : ∙For
	{
		token.T_10: "for",
	},
	// Statement : For ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement_List : ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Statement_List : Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement_List : ∙Statement_List Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Statement_List : Statement_List ∙Statement
	{
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
	},
	// Statement_List : Statement_List Statement ∙
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
}

var followSets = []map[token.Type]string{
	// Assignment_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Compound_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Declaration_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Empty_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Expression
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Expression_Statement
	{
		token.EOF:  "$",
		token.T_1:  ")",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// For
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Function_Argument
	{
		token.T_1:  ")",
		token.T_5:  ";",
		token.T_12: "identifier",
	},
	// Function_Argument_List
	{
		token.T_1: ")",
	},
	// Function_Argument_List_Body
	{
		token.T_1:  ")",
		token.T_12: "identifier",
	},
	// Function_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// GoGLL
	{
		token.EOF: "$",
	},
	// Identifier_Expression
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// IncDec_Expression
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Literal_Expression
	{
		token.T_1: ")",
		token.T_5: ";",
	},
	// Return_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Simple_Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
	// Statement_List
	{
		token.EOF:  "$",
		token.T_2:  "++",
		token.T_3:  "--",
		token.T_5:  ";",
		token.T_9:  "float_literal",
		token.T_10: "for",
		token.T_11: "func",
		token.T_12: "identifier",
		token.T_13: "integer_literal",
		token.T_14: "let",
		token.T_15: "return",
		token.T_16: "string_literal",
		token.T_17: "{",
		token.T_18: "}",
	},
}

/*** Errors ***/

/*
Error is returned by Parse at every point at which the parser fails to parse
a grammar production. For non-LL-1 grammars there will be an error for each
alternate attempted by the parser.

The errors are sorted in descending order of input position (index of token in
the stream of tokens).

Normally the error of interest is the one that has parsed the largest number of
tokens.
*/
type Error struct {
	// Index of token that caused the error.
	cI int

	// Grammar slot at which the error occured.
	Slot slot.Label

	// The token at which the error occurred.
	Token *token.Token

	// The line and column in the input text at which the error occurred
	Line, Column int

	// The tokens expected at the point where the error occurred
	Expected map[token.Type]string
}

func (pe *Error) String() string {
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "Parse Error: %s I[%d]=%s at line %d col %d\n",
		pe.Slot, pe.cI, pe.Token, pe.Line, pe.Column)
	exp := []string{}
	for _, e := range pe.Expected {
		exp = append(exp, e)
	}
	fmt.Fprintf(w, "Expected one of: [%s]", strings.Join(exp, ","))
	return w.String()
}

func (p *parser) parseError(slot slot.Label, i int, expected map[token.Type]string) {
	pe := &Error{cI: i, Slot: slot, Token: p.lex.Tokens[i], Expected: expected}
	p.parseErrors = append(p.parseErrors, pe)
}

func (p *parser) sortParseErrors() {
	sort.Slice(p.parseErrors,
		func(i, j int) bool {
			return p.parseErrors[j].Token.Lext() < p.parseErrors[i].Token.Lext()
		})
	for _, pe := range p.parseErrors {
		pe.Line, pe.Column = p.lex.GetLineColumn(pe.Token.Lext())
	}
}
