
//! Module token is generated by GoGLL. Do not edit

extern crate lazy_static;

use std::rc::Rc;
use std::fmt;
use lazy_static::lazy_static;
use std::collections::HashMap;

/// Token is returned by the lexer for every scanned lexical token
pub struct Token {
	pub typ: Type,
	pub lext: usize, 
	pub rext: usize,
	
	input: Rc<Vec<char>>,
}

#[derive(PartialEq, Eq, Hash, Clone, Copy)]
pub enum Type {	
	Error, // "Error"
	EOF, // "$"
	T_0, // "assign"
	T_1, // "break"
	T_2, // "colon"
	T_3, // "comma"
	T_4, // "comment"
	T_5, // "config"
	T_6, // "continue"
	T_7, // "dec"
	T_8, // "else"
	T_9, // "float_literal"
	T_10, // "for"
	T_11, // "function"
	T_12, // "identifier"
	T_13, // "if"
	T_14, // "in"
	T_15, // "inc"
	T_16, // "integer_literal"
	T_17, // "lbrace"
	T_18, // "let"
	T_19, // "lparen"
	T_20, // "rbrace"
	T_21, // "return"
	T_22, // "rparen"
	T_23, // "semicolon"
	T_24, // "string_literal"
	T_25, // "while"
	T_26, // "whitespace"
}

/**
New returns a new token.  
lext is the left extent and rext the right extent of the token in the input.  
input is the input slice scanned by the lexer.
*/
pub fn new<'a>(t: Type, lext: usize, rext: usize, input: &Rc<Vec<char>>) -> Rc<Token> {
	Rc::new(Token{
		typ:   t,
		lext:  lext,
		rext:  rext,
		input: input.clone(),
	})
}

impl Token {
	/// get_line_column returns the (line, column) of the left extent of the token
	pub fn get_line_column(&self) -> (usize, usize) {
		let mut line = 1;
		let mut col = 1;
		let mut j = 0;
		while j < self.lext {
			match self.input[j] {
			'\n' => {
				line += 1;
				col = 1
			},
			'\t' => col += 4,
			_ => col += 1
			}
			j += 1
		}
		(line, col)
	}

	/// returns the id of the token
	#[allow(dead_code)]
	pub fn id(&self) -> &'static str {
		TYPE_TO_ID[&self.typ]
	}
	
	/// literal returns the literal runes of t scanned by the lexer
	pub fn literal(&self) -> Vec<char> {
		self.input[self.lext..self.rext].to_vec()
	}
	
    /// literal_string returns the literal string of t scanned by the lexer
    #[allow(dead_code)]
	pub fn literal_string(&self) -> String {
		self.literal().iter().collect::<String>()
	}
	
	/// returns true iff this token is suppressed by the lexer
	#[allow(dead_code)]
	pub fn suppress(&self) -> bool {
		SUPPRESS[&self.typ]
	}

} // impl Token

impl <'a>fmt::Display for Token {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		let (ln, col) = self.get_line_column();
		write!(f, "({}, ({},{}) {})", 
			self.typ, ln, col, self.literal().iter().collect::<String>())
	}

}

impl <'a>Type {
	/// id returns the token type ID of token Type t
	#[allow(dead_code)]
	pub fn id(&self) -> &'a str {
		TYPE_TO_ID[self]
	}
	
}

impl <'a>fmt::Display for Type {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}", TYPE_TO_ID[self])
	}

}

lazy_static! {
    static ref TYPE_TO_ID: HashMap<Type, &'static str> = {
        let mut m = HashMap::new(); 
		m.insert(Type::Error, "Error");
		m.insert(Type::EOF, "$");
		m.insert(Type::T_0, "assign");
		m.insert(Type::T_1, "break");
		m.insert(Type::T_2, "colon");
		m.insert(Type::T_3, "comma");
		m.insert(Type::T_4, "comment");
		m.insert(Type::T_5, "config");
		m.insert(Type::T_6, "continue");
		m.insert(Type::T_7, "dec");
		m.insert(Type::T_8, "else");
		m.insert(Type::T_9, "float_literal");
		m.insert(Type::T_10, "for");
		m.insert(Type::T_11, "function");
		m.insert(Type::T_12, "identifier");
		m.insert(Type::T_13, "if");
		m.insert(Type::T_14, "in");
		m.insert(Type::T_15, "inc");
		m.insert(Type::T_16, "integer_literal");
		m.insert(Type::T_17, "lbrace");
		m.insert(Type::T_18, "let");
		m.insert(Type::T_19, "lparen");
		m.insert(Type::T_20, "rbrace");
		m.insert(Type::T_21, "return");
		m.insert(Type::T_22, "rparen");
		m.insert(Type::T_23, "semicolon");
		m.insert(Type::T_24, "string_literal");
		m.insert(Type::T_25, "while");
		m.insert(Type::T_26, "whitespace");
        m
    };
}

lazy_static! {
	static ref ID_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); 
		m.insert("Error", Type::Error); 
		m.insert("$", Type::EOF); 
		m.insert("assign", Type::T_0); 
		m.insert("break", Type::T_1); 
		m.insert("colon", Type::T_2); 
		m.insert("comma", Type::T_3); 
		m.insert("comment", Type::T_4); 
		m.insert("config", Type::T_5); 
		m.insert("continue", Type::T_6); 
		m.insert("dec", Type::T_7); 
		m.insert("else", Type::T_8); 
		m.insert("float_literal", Type::T_9); 
		m.insert("for", Type::T_10); 
		m.insert("function", Type::T_11); 
		m.insert("identifier", Type::T_12); 
		m.insert("if", Type::T_13); 
		m.insert("in", Type::T_14); 
		m.insert("inc", Type::T_15); 
		m.insert("integer_literal", Type::T_16); 
		m.insert("lbrace", Type::T_17); 
		m.insert("let", Type::T_18); 
		m.insert("lparen", Type::T_19); 
		m.insert("rbrace", Type::T_20); 
		m.insert("return", Type::T_21); 
		m.insert("rparen", Type::T_22); 
		m.insert("semicolon", Type::T_23); 
		m.insert("string_literal", Type::T_24); 
		m.insert("while", Type::T_25); 
		m.insert("whitespace", Type::T_26); 
		m
	};
}

lazy_static! {
	static ref STRING_TO_TYPE: HashMap<&'static str, Type> = {
		let mut m = HashMap::new(); 
		m.insert("Error", Type::Error); 
		m.insert("EOF", Type::EOF); 
		m.insert("T_0", Type::T_0); 
		m.insert("T_1", Type::T_1); 
		m.insert("T_2", Type::T_2); 
		m.insert("T_3", Type::T_3); 
		m.insert("T_4", Type::T_4); 
		m.insert("T_5", Type::T_5); 
		m.insert("T_6", Type::T_6); 
		m.insert("T_7", Type::T_7); 
		m.insert("T_8", Type::T_8); 
		m.insert("T_9", Type::T_9); 
		m.insert("T_10", Type::T_10); 
		m.insert("T_11", Type::T_11); 
		m.insert("T_12", Type::T_12); 
		m.insert("T_13", Type::T_13); 
		m.insert("T_14", Type::T_14); 
		m.insert("T_15", Type::T_15); 
		m.insert("T_16", Type::T_16); 
		m.insert("T_17", Type::T_17); 
		m.insert("T_18", Type::T_18); 
		m.insert("T_19", Type::T_19); 
		m.insert("T_20", Type::T_20); 
		m.insert("T_21", Type::T_21); 
		m.insert("T_22", Type::T_22); 
		m.insert("T_23", Type::T_23); 
		m.insert("T_24", Type::T_24); 
		m.insert("T_25", Type::T_25); 
		m.insert("T_26", Type::T_26); 
		m
	};
}

lazy_static! {
    static ref SUPPRESS: HashMap<Type, bool> = {
        let mut m = HashMap::new(); 
		m.insert(Type::Error, false);
		m.insert(Type::EOF, false);
		m.insert(Type::T_0, false);
		m.insert(Type::T_1, false);
		m.insert(Type::T_2, false);
		m.insert(Type::T_3, false);
		m.insert(Type::T_4, true);
		m.insert(Type::T_5, false);
		m.insert(Type::T_6, false);
		m.insert(Type::T_7, false);
		m.insert(Type::T_8, false);
		m.insert(Type::T_9, false);
		m.insert(Type::T_10, false);
		m.insert(Type::T_11, false);
		m.insert(Type::T_12, false);
		m.insert(Type::T_13, false);
		m.insert(Type::T_14, false);
		m.insert(Type::T_15, false);
		m.insert(Type::T_16, false);
		m.insert(Type::T_17, false);
		m.insert(Type::T_18, false);
		m.insert(Type::T_19, false);
		m.insert(Type::T_20, false);
		m.insert(Type::T_21, false);
		m.insert(Type::T_22, false);
		m.insert(Type::T_23, false);
		m.insert(Type::T_24, false);
		m.insert(Type::T_25, false);
		m.insert(Type::T_26, false);
        m
    };
}
