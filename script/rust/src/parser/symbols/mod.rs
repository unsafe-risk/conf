// Module symbols is generated by gogll. Do not edit.

use std::fmt;

#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum Symbol {
    NT(NT),
    T(T)
}

// NT is the type of non-terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum NT { 
    Assignment_Statement,
    Compound_Statement,
    Declaration_Statement,
    Empty_Statement,
    Expression,
    Expression_Statement,
    For,
    Function_Argument,
    Function_Argument_List,
    Function_Argument_List_Body,
    Function_Statement,
    GoGLL,
    Identifier_Expression,
    IncDec_Expression,
    Literal_Expression,
    Return_Statement,
    Simple_Statement,
    Statement,
    Statement_List,
}

// T is the type of terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum T { 
    T0, // assign 
    T1, // break 
    T2, // colon 
    T3, // comma 
    T4, // comment 
    T5, // config 
    T6, // continue 
    T7, // dec 
    T8, // else 
    T9, // float_literal 
    T10, // for 
    T11, // function 
    T12, // identifier 
    T13, // if 
    T14, // in 
    T15, // inc 
    T16, // integer_literal 
    T17, // lbrace 
    T18, // let 
    T19, // lparen 
    T20, // rbrace 
    T21, // return 
    T22, // rparen 
    T23, // semicolon 
    T24, // string_literal 
    T25, // while 
    T26, // whitespace 	
}

/// Format a &Vec<Symbol> into a String
#[allow(dead_code)]
pub fn to_string(symbols: &Vec<Symbol>) -> String {
    let mut st: String = "".to_string();
    for sym in symbols.iter() {
        st.push_str(&format!("{} ",sym));
    }
    st
}

impl Symbol {
    #[allow(dead_code)]
    pub fn is_nt(&self) -> bool {
        match self {
            Symbol::NT(_) => return true,
            Symbol::T(_) => return false,
        }
    }
}

impl fmt::Display for NT {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            NT::Assignment_Statement => write!(f, "Assignment_Statement"), 
            NT::Compound_Statement => write!(f, "Compound_Statement"), 
            NT::Declaration_Statement => write!(f, "Declaration_Statement"), 
            NT::Empty_Statement => write!(f, "Empty_Statement"), 
            NT::Expression => write!(f, "Expression"), 
            NT::Expression_Statement => write!(f, "Expression_Statement"), 
            NT::For => write!(f, "For"), 
            NT::Function_Argument => write!(f, "Function_Argument"), 
            NT::Function_Argument_List => write!(f, "Function_Argument_List"), 
            NT::Function_Argument_List_Body => write!(f, "Function_Argument_List_Body"), 
            NT::Function_Statement => write!(f, "Function_Statement"), 
            NT::GoGLL => write!(f, "GoGLL"), 
            NT::Identifier_Expression => write!(f, "Identifier_Expression"), 
            NT::IncDec_Expression => write!(f, "IncDec_Expression"), 
            NT::Literal_Expression => write!(f, "Literal_Expression"), 
            NT::Return_Statement => write!(f, "Return_Statement"), 
            NT::Simple_Statement => write!(f, "Simple_Statement"), 
            NT::Statement => write!(f, "Statement"), 
            NT::Statement_List => write!(f, "Statement_List"),
        }
    }
}

impl fmt::Display for T {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {  
            T::T0 => write!(f, "assign"), 
            T::T1 => write!(f, "break"), 
            T::T2 => write!(f, "colon"), 
            T::T3 => write!(f, "comma"), 
            T::T4 => write!(f, "comment"), 
            T::T5 => write!(f, "config"), 
            T::T6 => write!(f, "continue"), 
            T::T7 => write!(f, "dec"), 
            T::T8 => write!(f, "else"), 
            T::T9 => write!(f, "float_literal"), 
            T::T10 => write!(f, "for"), 
            T::T11 => write!(f, "function"), 
            T::T12 => write!(f, "identifier"), 
            T::T13 => write!(f, "if"), 
            T::T14 => write!(f, "in"), 
            T::T15 => write!(f, "inc"), 
            T::T16 => write!(f, "integer_literal"), 
            T::T17 => write!(f, "lbrace"), 
            T::T18 => write!(f, "let"), 
            T::T19 => write!(f, "lparen"), 
            T::T20 => write!(f, "rbrace"), 
            T::T21 => write!(f, "return"), 
            T::T22 => write!(f, "rparen"), 
            T::T23 => write!(f, "semicolon"), 
            T::T24 => write!(f, "string_literal"), 
            T::T25 => write!(f, "while"), 
            T::T26 => write!(f, "whitespace"),
        }
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { 
            Symbol::NT(nt) => write!(f, "{}", nt),
            Symbol::T(t) => write!(f, "{}", t)
        }
    }
}

